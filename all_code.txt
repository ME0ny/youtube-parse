
=== START FILE: D:\разработка\youtube-parser-os\manifest.json ===

{
    "manifest_version": 3,
    "name": "YouTube Рекомендации Парсер OS",
    "version": "1.0.0",
    "description": "Новый архитектурный фундамент для парсинга YouTube.",
    "icons": {
        "16": "icons/icon16.png"
    },
    "action": {
        "default_popup": "popup/popup.html",
        "default_icon": {
            "16": "icons/icon16.png"
        }
    },
    "background": {
        "service_worker": "background/background.js",
        "type": "module"
    },
    "content_scripts": [
        {
            "matches": [
                "*://*.youtube.com/*"
            ],
            "js": [
                "content/content.js"
            ],
            "run_at": "document_idle"
        }
    ],
    "permissions": [
        "activeTab",
        "scripting",
        "storage",
        "tabs"
    ],
    "host_permissions": [
        "*://*.youtube.com/*"
    ]
}

=== END FILE: D:\разработка\youtube-parser-os\manifest.json ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\adapters\ChromeStorageLogAdapter.js ===

// adapters/ChromeStorageLogAdapter.js
import { Logger } from '../core/logger.js'; // Для типов

/**
 * @typedef {import('../core/types/log.types.js').LogEntry} LogEntry
 * @typedef {import('../core/types/log.types.js').LogAdapter} LogAdapter
 */

export class ChromeStorageLogAdapter {
    /** @type {string} */
    #storageKey;
    /** @type {number} */
    #maxSize;

    /**
     * @param {Object} options
     * @param {string} [options.storageKey='appLogs']
     * @param {number} [options.maxSize=500]
     */
    constructor(options = {}) {
        // Проверяем доступность chrome.storage.local
        if (typeof chrome === 'undefined' || !chrome.storage || !chrome.storage.local) {
            throw new Error('ChromeStorageLogAdapter: chrome.storage.local is not available.');
        }

        this.#storageKey = options.storageKey ?? 'appLogs';
        this.#maxSize = options.maxSize ?? 500;
    }

    /**
     * @param {LogEntry} entry
     * @returns {Promise<void>}
     */
    async write(entry) {
        try {
            const logs = await this.read();
            logs.push(entry);
            if (logs.length > this.#maxSize) {
                logs.splice(0, logs.length - this.#maxSize);
            }
            await chrome.storage.local.set({ [this.#storageKey]: logs });
        } catch (e) {
            console.error("[ChromeStorageLogAdapter] Ошибка записи:", e);
            // В реальном адаптере можно выбрасывать ошибку или логировать иначе
            // throw e;
        }
    }

    /**
     * @returns {Promise<LogEntry[]>}
     */
    async read() {
        try {
            const result = await chrome.storage.local.get([this.#storageKey]);
            return result[this.#storageKey] || [];
        } catch (e) {
            console.error("[ChromeStorageLogAdapter] Ошибка чтения:", e);
            return [];
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async clear() {
        try {
            await chrome.storage.local.remove([this.#storageKey]);
        } catch (e) {
            console.error("[ChromeStorageLogAdapter] Ошибка очистки:", e);
        }
    }
}

=== END FILE: D:\разработка\youtube-parser-os\adapters\ChromeStorageLogAdapter.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\adapters\ChromeStorageTableAdapter.js ===

// adapters/ChromeStorageTableAdapter.js

/**
 * @typedef {import('../core/types/table.types.js').VideoData} VideoData
 * @typedef {import('../core/types/table.types.js').TableAdapter} TableAdapter
 */

export class ChromeStorageTableAdapter {
    /** @type {string} */
    #storageKey;
    /** @type {number} */
    #maxSize;

    /**
     * @param {Object} options
     * @param {string} [options.storageKey='parsedVideos']
     * @param {number} [options.maxSize=100000]
     */
    constructor(options = {}) {
        if (typeof chrome === 'undefined' || !chrome.storage || !chrome.storage.local) {
            throw new Error('ChromeStorageTableAdapter: chrome.storage.local is not available.');
        }

        this.#storageKey = options.storageKey ?? 'parsedVideos';
        this.#maxSize = options.maxSize ?? 100000; // Увеличенный размер для больших данных
    }

    /**
     * @param {VideoData} videoData
     * @returns {Promise<void>}
     */
    async add(videoData) {
        try {
            const allData = await this.getAll();
            allData.push(videoData);

            // Ограничиваем размер, удаляя старые записи с начала
            if (allData.length > this.#maxSize) {
                allData.splice(0, allData.length - this.#maxSize);
            }

            await chrome.storage.local.set({ [this.#storageKey]: allData });

            // Отправляем сообщение всем popup'ам об обновлении данных
            this.#broadcastDataUpdate();
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка добавления записи:", e);
            throw e;
        }
    }

    /**
     * @param {VideoData[]} videoDataArray
     * @returns {Promise<void>}
     */
    async addBatch(videoDataArray) {
        if (!Array.isArray(videoDataArray) || videoDataArray.length === 0) {
            return;
        }

        try {
            const allData = await this.getAll();
            allData.push(...videoDataArray);

            // Ограничиваем размер
            if (allData.length > this.#maxSize) {
                allData.splice(0, allData.length - this.#maxSize);
            }

            await chrome.storage.local.set({ [this.#storageKey]: allData });

            // Отправляем сообщение об обновлении данных
            this.#broadcastDataUpdate();
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка добавления записей:", e);
            throw e;
        }
    }

    /**
     * @returns {Promise<VideoData[]>}
     */
    async getAll() {
        try {
            const result = await chrome.storage.local.get([this.#storageKey]);
            return result[this.#storageKey] || [];
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка получения записей:", e);
            return [];
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async clear() {
        try {
            await chrome.storage.local.remove([this.#storageKey]);
            // Отправляем сообщение об очистке данных
            this.#broadcastDataCleared();
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка очистки:", e);
            throw e;
        }
    }

    /**
     * @returns {Promise<number>}
     */
    async getCount() {
        try {
            const data = await this.getAll();
            return data.length;
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка получения количества записей:", e);
            return 0;
        }
    }

    /**
     * Получает все записи, которые НЕ являются импортированными.
     * Используется для отображения в UI.
     * @returns {Promise<import('../core/types/table.types.js').VideoData[]>}
     */
    async getFreshData() {
        try {
            const allData = await this.getAll();
            // Фильтруем, оставляя только "свежие" записи
            return allData.filter(item => !item.isImported);
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка получения свежих данных:", e);
            return [];
        }
    }

    /**
     * Очищает только записи, помеченные как импортированные (isImported: true).
     * @returns {Promise<void>}
     */
    async clearImported() {
        try {
            console.log("[ChromeStorageTableAdapter] Начало очистки импортированных данных...");
            // 1. Получаем все данные
            const allData = await this.getAll();
            console.log(`[ChromeStorageTableAdapter] Всего записей до очистки: ${allData.length}`);

            // 2. Фильтруем, оставляя только НЕ импортированные данные
            const freshData = allData.filter(item => !item.isImported);
            console.log(`[ChromeStorageTableAdapter] Останется записей после очистки: ${freshData.length}`);

            // 3. Сохраняем обратно только "свежие" данные
            // Используем максимальный размер для сохранения
            if (freshData.length > this.#maxSize) {
                freshData.splice(0, freshData.length - this.#maxSize);
            }

            await chrome.storage.local.set({ [this.#storageKey]: freshData });
            console.log("[ChromeStorageTableAdapter] Импортированные данные успешно удалены из хранилища.");

            // 4. Отправляем сообщение об обновлении данных, так как состав изменился
            // Это заставит popup перезагрузить "свежие" данные
            this.#broadcastDataUpdate();

        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка очистки импортированных данных:", e);
            throw e;
        }
    }

    /**
     * Отправляет сообщение о том, что данные обновились.
     * @private
     */
    #broadcastDataUpdate() {
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            chrome.runtime.sendMessage({ type: "dataUpdated" }).catch(err => {
                // Игнорируем ошибки, если popup закрыт
                if (!chrome.runtime.lastError) {
                    console.debug("Ошибка при отправке dataUpdated:", err);
                }
            });
        }
    }

    /**
     * Отправляет сообщение о том, что данные очищены.
     * @private
     */
    #broadcastDataCleared() {
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            chrome.runtime.sendMessage({ type: "dataCleared" }).catch(err => {
                if (!chrome.runtime.lastError) {
                    console.debug("Ошибка при отправке dataCleared:", err);
                }
            });
        }
    }
}

=== END FILE: D:\разработка\youtube-parser-os\adapters\ChromeStorageTableAdapter.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\adapters\ConsoleLogAdapter.js ===

// adapters/ConsoleLogAdapter.js

/**
 * @typedef {import('../core/types/log.types.js').LogEntry} LogEntry
 * @typedef {import('../core/types/log.types.js').LogAdapter} LogAdapter
 */

export class ConsoleLogAdapter {
    /**
     * @param {LogEntry} entry
     * @returns {Promise<void>}
     */
    async write(entry) {
        // Логика уже есть в основном классе, но можно и здесь реализовать
        // например, если нужен специфичный формат только для консоли
        // Пока оставим пустым, так как дублирование происходит в Logger
    }

    /**
     * @returns {Promise<LogEntry[]>}
     */
    async read() {
        console.warn("[ConsoleLogAdapter] Чтение логов из консоли невозможно");
        return [];
    }

    /**
     * @returns {Promise<void>}
     */
    async clear() {
        console.clear(); // Физически очищает консоль браузера
    }
}

=== END FILE: D:\разработка\youtube-parser-os\adapters\ConsoleLogAdapter.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\background\background.js ===

// background/background.js
// Импортируем новые модули
import { Logger } from '../core/logger.js';
import { ChromeStorageLogAdapter } from '../adapters/ChromeStorageLogAdapter.js';
import { ChromeStorageTableAdapter } from '../adapters/ChromeStorageTableAdapter.js';
import { ScenarioEngine } from '../core/scenario-engine.js';
import { testCountdownScenario } from '../scenarios/test-countdown.js';
import { prepareImportedDataIndices } from '../core/data-processor.js';
import { parseRecommendationScenario } from '../scenarios/parse-recommendation.js';

// --- Инициализация нового функционала ---
// 1. Создаем экземпляр логгера
export const logger = new Logger({
    maxSize: 1000,
    enableConsole: true,
    defaultLevel: 'info'
});

export const tableAdapter = new ChromeStorageTableAdapter({
    maxSize: 100000 // Установим большой лимит
});

export async function getImportedDataIndices() {
    try {
        const allData = await tableAdapter.getAll();
        // Фильтруем только импортированные данные
        const importedData = allData.filter(item => item.isImported === true);
        logger.debug(`[Background] Получено ${importedData.length} импортированных записей для индексации.`, { module: 'Background' });
        return prepareImportedDataIndices(importedData);
    } catch (error) {
        logger.error(`[Background] Ошибка при получении/индексации импортированных данных: ${error.message}`, { module: 'Background' });
        // Возвращаем пустые структуры в случае ошибки
        return {
            visitedVideoIds: new Set(),
            channelVideoCounts: new Map(),
            channelToVideoIds: new Map()
        };
    }
}
// logger по умолчанию уже добавил ChromeStorageLogAdapter, но мы можем добавить ещё

// 2. Создаем экземпляр движка сценариев
export const scenarioEngine = new ScenarioEngine();

// 3. Регистрируем тестовый сценарий
scenarioEngine.registerScenario(testCountdownScenario);
scenarioEngine.registerScenario(parseRecommendationScenario);
// --- Конец инициализации нового функционала ---

// --- Обработка сообщений от popup ---
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {

    if (request.action === "getScenarioStatus") {
        console.log("[Background] 📥 [getScenarioStatus] НАЧАЛО обработки запроса");
        logger.debug("📥 [Background] Получен запрос состояния сценариев", { module: 'Background' });

        // ВАЖНО: Вернуть true СРАЗУ, до выполнения асинхронной операции
        // Это сигнализирует Chrome, что ответ будет асинхронным
        (async () => {
            try {
                console.log("[Background] [getScenarioStatus] Начинаем выполнение асинхронной логики...");

                // Имитируем возможную задержку или сложную операцию
                // await new Promise(r => setTimeout(r, 100)); 

                console.log("[Background] [getScenarioStatus] Вызываем scenarioEngine.getRunningScenarios()");
                const runningScenarios = scenarioEngine.getRunningScenarios();
                console.log("[Background] [getScenarioStatus] Получен список запущенных сценариев:", runningScenarios);

                const isRunning = runningScenarios.length > 0;
                const responsePayload = {
                    status: "success",
                    isRunning: isRunning,
                    runningScenarios: runningScenarios
                };

                logger.debug(`📤 [Background] Отправляем состояние сценариев: isRunning=${isRunning}`, { module: 'Background' });
                console.log("[Background] [getScenarioStatus] Подготавливаем ответ для отправки:", responsePayload);

                // КРИТИЧЕСКИ ВАЖНО: sendResponse должен быть вызван в этой асинхронной функции
                console.log("[Background] [getScenarioStatus] Вызываем sendResponse...");
                sendResponse(responsePayload);
                console.log("[Background] [getScenarioStatus] sendResponse вызван успешно.");

            } catch (err) {
                console.error("[Background] ❌ [getScenarioStatus] ПОЙМАНА ОШИБКА:", err);
                logger.error(`❌ [Background] Ошибка при получении состояния сценариев: ${err.message}`, { module: 'Background' });

                // Даже в случае ошибки НУЖНО вызвать sendResponse
                console.log("[Background] [getScenarioStatus] Вызываем sendResponse с ошибкой...");
                sendResponse({ status: "error", message: err.message });
                console.log("[Background] [getScenarioStatus] sendResponse с ошибкой вызван.");
            }
        })(); // Немедленный вызов асинхронной функции

        console.log("[Background] 📤 [getScenarioStatus] Обработчик вернул true, ожидаем асинхронный ответ.");
        return true; // keep channel open for async response
    }

    if (request.type === "contentLog") {
        console.log("[Background] Получен лог от content script:", request);
        // Перенаправляем лог в наш logger
        logger.log(
            request.message,
            request.level || 'info',
            {
                module: request.module || 'ContentScript',
                // Можно добавить ID вкладки, если нужно
                // tabId: sender.tab?.id
            }
        );
        // Намеренно не отправляем sendResponse, так как это одностороннее сообщение
        return false; // Не нужно ждать асинхронного ответа
    }

    if (request.action === "stopAllScenarios") {
        logger.info("📥 Получена команда на остановку всех сценариев", { module: 'Background' });
        (async () => {
            try {
                // Получаем список всех запущенных сценариев
                const runningScenarios = scenarioEngine.getRunningScenarios();
                if (runningScenarios.length === 0) {
                    logger.info("📭 Нет запущенных сценариев для остановки", { module: 'Background' });
                    sendResponse({ status: "success", message: "Нет запущенных сценариев" });
                    return;
                }

                logger.info(`⏹️ Запрошена остановка ${runningScenarios.length} сценариев`, { module: 'Background' });

                let stoppedCount = 0;
                let errorCount = 0;

                const stopPromises = runningScenarios.map(async (scenario) => {
                    try {
                        // ScenarioEngine.stop возвращает true, если сценарий был найден и остановлен
                        const wasStopped = scenarioEngine.stop(scenario.id);
                        if (wasStopped) {
                            stoppedCount++;
                            logger.info(`⏹️ Сценарий "${scenario.name}" (ID: ${scenario.id}) остановлен`, { module: 'Background' });
                        } else {
                            // Это маловероятно, так как мы только что получили список запущенных
                            logger.warn(`⚠️ Сценарий "${scenario.name}" (ID: ${scenario.id}) не был остановлен (уже завершен?)`, { module: 'Background' });
                        }
                    } catch (err) {
                        errorCount++;
                        logger.error(`❌ Ошибка при остановке сценария "${scenario.name}" (ID: ${scenario.id}): ${err.message}`, { module: 'Background' });
                    }
                });

                // Ждем завершения всех попыток остановки
                await Promise.allSettled(stopPromises);

                const resultMessage = `Остановлено сценариев: ${stoppedCount}. Ошибок: ${errorCount}.`;
                logger.info(`🏁 Результат остановки: ${resultMessage}`, { module: 'Background' });

                sendResponse({ status: "success", message: resultMessage });

            } catch (err) {
                logger.error(`❌ Ошибка при остановке сценариев: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    if (request.action === "runScenario") {
        const { scenarioId, params = {} } = request;
        logger.info(`📥 Получена команда на запуск сценария "${scenarioId}"`, { module: 'Background', meta: params });

        (async () => {
            try {
                let activeTabId = null;
                try {
                    const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });
                    activeTabId = activeTab?.id || null;
                } catch (e) {
                    logger.warn("Не удалось получить активную вкладку для сценария", { module: 'Background' });
                }

                // Определяем, какой сценарий запускать
                let scenarioToRun;
                if (scenarioId === 'parse-recommendation') {
                    scenarioToRun = parseRecommendationScenario;
                } else if (scenarioId === 'test-countdown') {
                    scenarioToRun = testCountdownScenario;
                    // } else if (scenarioId === '...') {
                    //     scenarioToRun = ...;
                } else {
                    throw new Error(`Неизвестный ID сценария: ${scenarioId}`);
                }

                // Передаем параметры в сценарий через context.params
                const instanceId = await scenarioEngine.run(scenarioToRun, params, activeTabId);
                logger.info(`🏁 Сценарий "${scenarioId}" запущен с ID: ${instanceId}`, { module: 'Background' });

                // 👇 Отправляем подтверждение запуска с ID инстанса
                sendResponse({ status: "started", instanceId: instanceId });

                // Опционально: отправляем сообщение в popup о начале (если нужно немедленное уведомление до завершения сценария)
                // chrome.runtime.sendMessage({ type: "scenarioStatus", status: "started", message: `Сценарий "${scenarioId}" начат.`, level: "info" });

            } catch (err) {
                logger.error(`❌ Ошибка запуска сценария "${scenarioId}": ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();

        return true; // keep channel open for async response
    }

    if (request.action === "clearImportedTableData") {
        (async () => {
            try {
                logger.info("📥 Получена команда на очистку импортированных данных", { module: 'Background' });

                // Вызываем метод адаптера
                await tableAdapter.clearImported();

                logger.info("✅ Импортированные данные очищены", { module: 'Background' });
                sendResponse({ status: "success" });

            } catch (err) {
                logger.error(`❌ Ошибка очистки импортированных данных: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    if (request.action === "getTableFreshData") {
        (async () => {
            try {
                // Используем новый метод адаптера
                const data = await tableAdapter.getFreshData();
                sendResponse({ status: "success", data });
            } catch (err) {
                logger.error(`❌ Ошибка получения свежих данных таблицы: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // Указывает, что ответ будет асинхронным
    }

    if (request.action === "DEBUG_getImportedDataIndices") {
        (async () => {
            try {
                console.log("[DEBUG] Получение индексов импортированных данных по запросу из popup/console...");
                const indices = await getImportedDataIndices(); // Эта функция доступна внутри модуля

                // Maps и Sets нужно сериализовать для отправки
                const serializableData = {
                    visitedVideoIds_size: indices.visitedVideoIds.size,
                    channelVideoCounts_size: indices.channelVideoCounts.size,
                    channelToVideoIds_size: indices.channelToVideoIds.size,

                    // Добавим примеры для лучшей проверки
                    visitedVideoIds_sample: Array.from(indices.visitedVideoIds).slice(0, 5),
                    channelVideoCounts_sample: Object.fromEntries(
                        Array.from(indices.channelVideoCounts).slice(0, 5)
                    ),
                    channelToVideoIds_sample: Object.fromEntries(
                        Array.from(indices.channelToVideoIds, ([k, v]) => [k, Array.from(v).slice(0, 3)]).slice(0, 3)
                    )
                };

                console.log("[DEBUG] Индексы получены:", serializableData);
                sendResponse({ status: "success", data: serializableData });
            } catch (err) {
                console.error("[DEBUG] Ошибка в getImportedDataIndices:", err);
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    if (request.action === "importTableData") {
        (async () => {
            try {
                if (!request.data || !Array.isArray(request.data)) {
                    const errorMsg = "Некорректные данные для импорта";
                    console.error("[Background] importTableData:", errorMsg);
                    sendResponse({ status: "error", message: errorMsg });
                    return;
                }

                const dataToImport = request.data;

                // 1. Получаем существующие данные
                let existingData = [];
                try {
                    existingData = await tableAdapter.getAll();
                } catch (getErr) {
                    console.warn("[Background] Не удалось получить существующие данные, начинаем с пустого массива:", getErr.message);
                }

                // 2. Объединяем данные (можно просто добавить, или реализовать объединение/замещение)
                // Для простоты, просто добавляем в конец.
                const combinedData = [...existingData, ...dataToImport];

                // 3. Сохраняем в хранилище через адаптер
                // tableAdapter.addBatch ожидает массив VideoData. Убедимся, что формат правильный.
                // addBatch внутри адаптера тоже вызывает getAll, добавляет и set.
                // Чтобы упростить и избежать двойного getAll, можно напрямую использовать set,
                // но лучше использовать API адаптера. Реализуем addBatch, если его нет.
                // Проверим, есть ли addBatch:
                if (typeof tableAdapter.addBatch === 'function') {
                    await tableAdapter.addBatch(dataToImport);
                } else if (typeof tableAdapter.add === 'function') {
                    // Если addBatch нет, добавляем по одной (менее эффективно)
                    for (const item of dataToImport) {
                        await tableAdapter.add(item);
                    }
                } else {
                    const errorMsg = "Адаптер таблицы не поддерживает методы добавления";
                    console.error("[Background] importTableData:", errorMsg);
                    sendResponse({ status: "error", message: errorMsg });
                    return;
                }

                logger.info(`📥 Импортировано ${dataToImport.length} записей в таблицу`, { module: 'Background' });

                sendResponse({ status: "success", count: dataToImport.length });

            } catch (err) {
                console.error("[Background] Ошибка при импорте данных:", err);
                logger.error(`❌ Ошибка импорта данных: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    if (request.action === "getImportedDataIndices") {
        (async () => {
            try {
                const indices = await getImportedDataIndices();
                // Maps и Sets нельзя напрямую сериализовать в JSON, поэтому преобразуем
                const serializableIndices = {
                    visitedVideoIds: Array.from(indices.visitedVideoIds),
                    channelVideoCounts: Object.fromEntries(indices.channelVideoCounts),
                    channelToVideoIds: {} // Преобразуем Map<channel, Set<id>> в объект
                };
                for (const [channel, idSet] of indices.channelToVideoIds) {
                    serializableIndices.channelToVideoIds[channel] = Array.from(idSet);
                }
                sendResponse({ status: "success", data: serializableIndices });
            } catch (err) {
                logger.error(`[Background] Ошибка получения индексов: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // Для асинхронной отправки ответа
    }

    if (request.action === "getTableData") {
        (async () => {
            try {
                const data = await tableAdapter.getAll();
                sendResponse({ status: "success", data });
            } catch (err) {
                logger.error(`❌ Ошибка получения данных таблицы: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // Указывает, что ответ будет асинхронным
    }

    if (request.action === "clearTableData") {
        (async () => {
            try {
                await tableAdapter.clear();
                sendResponse({ status: "success" });
                logger.info("✅ Таблица очищена", { module: 'Background' });
            } catch (err) {
                logger.error(`❌ Ошибка очистки таблицы: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true;
    }

    if (request.action === "copyTableData") {
        (async () => {
            try {
                const data = await tableAdapter.getAll();
                // Фильтруем импортированные данные, если нужно
                const freshData = data.filter(v => !v.isImported);

                const headers = ['Название', 'ID', 'Просмотры', 'Канал', 'Исходное видео', 'Миниатюра'];
                const rows = freshData.map(v => [
                    v.title || '', v.videoId || '', v.views || '', v.channelName || '', v.sourceVideoId || '', v.thumbnailUrl || ''
                ]);

                const tsvContent = [headers.join('\t'), ...rows.map(r => r.join('\t'))].join('\n');
                sendResponse({ status: "success", data: tsvContent });
                logger.info(`📋 Таблица подготовлена для копирования (${freshData.length} строк)`, { module: 'Background' });
            } catch (err) {
                logger.error(`❌ Ошибка подготовки таблицы для копирования: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true;
    }

});

logger.info("🚀 Background service worker запущен и готов к работе.", { module: 'Background' });

=== END FILE: D:\разработка\youtube-parser-os\background\background.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\content\content.js ===

// content/content.js

// Хранилище для активных операций скроллинга
const activeScrollOperations = new Map();

/**
 * Прокручивает страницу N раз с задержкой.
 * @param {string} scenarioId - ID сценария (для связи с сообщением об отмене).
 * @param {number} count - сколько раз скроллить
 * @param {number} delayMs - задержка между скроллами
 * @param {number} step - на сколько пикселей скроллить за раз
 * @param {Function} onProgress - callback для обновления прогресса
 * @param {Function} onAbort - callback, вызываемый при получении команды на отмену
 * @returns {Promise<{status: string, cardCount?: number, message?: string}>}
 */
function performScrollNTimes(scenarioId, count = 16, delayMs = 1500, step = 1000, onProgress = null) {
    return new Promise((resolve) => {
        let current = 0;
        const total = count;
        let isAborted = false;

        // Функция для проверки отмены и завершения
        const checkAndFinish = (status, message, cardCount = null) => {
            activeScrollOperations.delete(scenarioId);
            if (status === "aborted") {
                resolve({ status, message });
            } else {
                const finalCardCount = cardCount !== null ? cardCount : document.querySelectorAll('ytd-rich-item-renderer, ytd-compact-video-renderer').length;
                resolve({ status, cardCount: finalCardCount, message });
            }
        };

        // Регистрируем операцию как активную
        activeScrollOperations.set(scenarioId, {
            abort: () => {
                isAborted = true;
                checkAndFinish("aborted", `Скроллинг для сценария ${scenarioId} остановлен.`);
            }
        });

        const scroll = () => {
            if (isAborted) {
                checkAndFinish("aborted", `Скроллинг остановлен на шаге ${current}/${total} для сценария ${scenarioId}.`);
                return;
            }

            if (current >= total) {
                checkAndFinish("success", `Скроллинг завершён для сценария ${scenarioId}.`);
                return;
            }

            window.scrollBy(0, step);
            current++;

            if (onProgress) {
                onProgress(current, total);
            }

            setTimeout(scroll, delayMs);
        };

        console.log(`[Content Script] Начинаем скроллинг для сценария ${scenarioId}`);
        scroll();
    });
}


// Слушаем сообщения от background.js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    console.log("[Content Script] Получено сообщение:", request);

    if (request.action === "scrollNTimes") {
        console.log("[Content Script] Получена команда scrollNTimes:", request);

        (async () => {
            try {
                const result = await performScrollNTimes(
                    request.scenarioId,
                    request.count,
                    request.delayMs,
                    request.step,
                    async (current, total) => {
                        try {
                            await chrome.runtime.sendMessage({
                                type: "contentLog",
                                message: `Прогресс скроллинга: ${current}/${total}`,
                                level: "info",
                                module: "ContentScroller"
                            });
                        } catch (err) {
                            console.debug("Не удалось отправить промежуточный лог скроллинга:", err);
                        }
                    }
                );
                console.log("[Content Script] Скроллинг завершён, отправляем результат:", result);
                sendResponse(result);
            } catch (err) {
                console.error("[Content Script] Ошибка скроллинга:", err);
                sendResponse({ status: "error", message: err.message });
            }
        })();

        return true; // Указываем, что ответ асинхронный
    }

    // Другие обработчики сообщений...
    // if (request.action === "parseAndHighlight") { ... }
    // if (request.action === "navigateToVideo") { ... }

});

=== END FILE: D:\разработка\youtube-parser-os\content\content.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\data-processor.js ===

// core/data-processor.js

/**
 * @typedef {import('./types/table.types.js').VideoData} VideoData
 */

/**
 * Подготавливает индексы и структуры данных из массива видео (например, импортированных).
 * @param {VideoData[]} videoDataArray - Массив объектов видео.
 * @returns {Object} Объект с подготовленными структурами.
 * @returns {Set<string>} .visitedVideoIds - Множество ID видео, НА КОТОРЫЕ УЖЕ ЗАХОДИЛИ (sourceVideoId).
 * @returns {Map<string, number>} .channelVideoCounts - Словарь: канал -> количество видео из этого канала.
 * @returns {Map<string, Set<string>>} .channelToVideoIds - Словарь: канал -> множество ID видео этого канала (videoId).
 */
export function prepareImportedDataIndices(videoDataArray) {
    // 1. Сет видео, на которые уже заходили (sourceVideoId)
    // Это видео, с которых был совершен переход, т.е. они уже были "текущими".
    const visitedVideoIds = new Set();

    // 2. Словарь: канал -> количество видео из этого канала
    const channelVideoCounts = new Map();

    // 3. Словарь: канал -> множество ID видео этого канала (videoId)
    const channelToVideoIds = new Map();

    if (!Array.isArray(videoDataArray)) {
        console.warn("[DataProcessor] Входные данные не являются массивом.");
        return { visitedVideoIds, channelVideoCounts, channelToVideoIds };
    }

    for (const video of videoDataArray) {
        // --- 1. Заполняем visitedVideoIds ---
        // ВАЖНО: Используем sourceVideoId, так как это ID видео,
        // на котором мы "останавливались" и с которого переходили.
        // Это предотвратит повторный переход на это же видео.
        if (video.sourceVideoId) {
            visitedVideoIds.add(video.sourceVideoId);
        }
        // Если нужно также отслеживать videoId (например, чтобы не добавлять дубликаты видео в таблицу),
        // можно добавить отдельный сет, например, allParsedVideoIds. Но для visitedVideoIds - это sourceVideoId.

        // --- 2. Заполняем channelVideoCounts ---
        const channel = video.channelName || 'Неизвестный канал';
        const currentCount = channelVideoCounts.get(channel) || 0;
        channelVideoCounts.set(channel, currentCount + 1);

        // --- 3. Заполняем channelToVideoIds ---
        // Здесь используем videoId, так как мы хотим знать, какие конкретные видео
        // принадлежат каналу.
        if (!channelToVideoIds.has(channel)) {
            channelToVideoIds.set(channel, new Set());
        }
        if (video.videoId) {
            channelToVideoIds.get(channel).add(video.videoId);
        }
    }

    return {
        visitedVideoIds,
        channelVideoCounts,
        channelToVideoIds
    };
}

=== END FILE: D:\разработка\youtube-parser-os\core\data-processor.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\logger.js ===

// core/logger.js
import { ChromeStorageLogAdapter } from '../adapters/ChromeStorageLogAdapter.js';

/**
 * @typedef {import('./types/log.types.js').LogEntry} LogEntry
 * @typedef {import('./types/log.types.js').LoggerConfig} LoggerConfig
 * @typedef {import('./types/log.types.js').LogAdapter} LogAdapter
 * @typedef {import('./types/log.types.js').LogSubscriber} LogSubscriber
 */

export class Logger {
    /** @type {LogAdapter[]} */
    #adapters = [];
    /** @type {LogSubscriber[]} */
    #subscribers = [];
    /** @type {LoggerConfig} */
    #config;

    /**
     * @param {LoggerConfig} config
     */
    constructor(config = {}) {
        this.#config = {
            maxSize: config.maxSize ?? 1000,
            enableConsole: config.enableConsole ?? true,
            defaultLevel: config.defaultLevel ?? 'info',
        };

        // По умолчанию добавляем адаптер для Chrome Storage
        this.addAdapter(new ChromeStorageLogAdapter({ maxSize: this.#config.maxSize }));
    }

    /**
     * Добавляет адаптер для хранения/вывода логов.
     * @param {LogAdapter} adapter
     */
    addAdapter(adapter) {
        this.#adapters.push(adapter);
    }

    /**
     * Подписывается на новые логи и команды (например, очистка).
     * @param {LogSubscriber} callback
     */
    subscribe(callback) {
        this.#subscribers.push(callback);
    }

    /**
     * Отписывается от новых логов.
     * @param {LogSubscriber} callback
     */
    unsubscribe(callback) {
        this.#subscribers = this.#subscribers.filter(cb => cb !== callback);
    }

    /**
     * Создает и записывает лог-запись.
     * @param {string} message
     * @param {'debug'|'info'|'success'|'warn'|'error'} [level]
     * @param {Object} [options]
     * @param {string} [options.module]
     * @param {string} [options.contextId]
     * @param {Object} [options.meta]
     */
    async log(message, level = this.#config.defaultLevel, options = {}) {
        const entry = {
            id: this.#generateId(),
            timestamp: Date.now(),
            level,
            message,
            module: options.module,
            contextId: options.contextId,
            meta: options.meta,
        };

        // 1. Запись через адаптеры
        const writePromises = this.#adapters.map(adapter => adapter.write(entry));
        await Promise.allSettled(writePromises); // Не прерываемся из-за ошибки одного адаптера

        // 2. Дублирование в консоль (если включено)
        if (this.#config.enableConsole) {
            this.#logToConsole(entry);
        }

        // 3. Уведомление подписчиков
        this.#notifySubscribers(entry);

        // 4. 👇 НОВОЕ: Отправка сообщения в popup (если в background)
        // Проверяем, что мы в Service Worker (background)
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            try {
                // Используем стрелочную функцию для правильного контекста this
                chrome.runtime.sendMessage({
                    type: "newLog",
                    log: entry
                }).catch(err => {
                    // Это обработка ошибки асинхронной операции sendMessage
                    if (chrome.runtime.lastError) {
                        // Это нормально, если popup закрыт
                        // console.debug("Popup недоступен для sendMessage:", chrome.runtime.lastError.message);
                    } else {
                        console.debug("Ошибка при отправке лога в popup (асинхронная):", err);
                    }
                });
            } catch (syncSendError) {
                // Это обработка синхронной ошибки при вызове sendMessage
                // Может возникнуть, если API недоступен в текущем контексте (редко)
                console.debug("Синхронная ошибка при вызове sendMessage:", syncSendError);
            }
        }
    }

    /**
     * Получает все логи из всех адаптеров (берет из первого доступного).
     * @returns {Promise<LogEntry[]>}
     */
    async getAllLogs() {
        for (const adapter of this.#adapters) {
            try {
                const logs = await adapter.read();
                return logs;
            } catch (e) {
                console.warn("[Logger] Не удалось получить логи из адаптера:", e);
            }
        }
        return []; // Если ни один адаптер не сработал
    }

    /**
     * Очищает логи во всех адаптерах.
     * @returns {Promise<void>}
     */
    async clear() {
        const clearPromises = this.#adapters.map(adapter => adapter.clear());
        await Promise.allSettled(clearPromises);
        // Уведомляем подписчиков об очистке
        this.#notifySubscribers({ type: 'CLEAR_LOGS' });
    }

    // --- Вспомогательные методы ---

    /**
     * Удобные методы для разных уровней
     */
    debug(message, options = {}) { return this.log(message, 'debug', options); }
    info(message, options = {}) { return this.log(message, 'info', options); }
    success(message, options = {}) { return this.log(message, 'success', options); }
    warn(message, options = {}) { return this.log(message, 'warn', options); }
    error(message, options = {}) { return this.log(message, 'error', options); }

    /**
     * Генерирует уникальный ID для записи.
     * @returns {string}
     */
    #generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Выводит лог в консоль браузера.
     * @param {LogEntry} entry
     */
    #logToConsole(entry) {
        const time = new Date(entry.timestamp).toLocaleTimeString();
        const prefix = `[${time}] [${entry.level.toUpperCase()}]`;
        const suffix = entry.module ? `[${entry.module}]` : '';
        const context = entry.contextId ? `(ctx:${entry.contextId})` : '';

        const consoleMethod = entry.level === 'error' ? console.error :
            entry.level === 'warn' ? console.warn :
                entry.level === 'debug' ? console.debug : console.log;

        consoleMethod(`${prefix} ${entry.message} ${suffix} ${context}`, entry.meta || '');
    }

    /**
     * Уведомляет всех подписчиков.
     * @param {LogEntry | { type: 'CLEAR_LOGS' }} entry
     */
    #notifySubscribers(entry) {
        this.#subscribers.forEach(callback => {
            try {
                callback(entry);
            } catch (e) {
                console.error("[Logger] Ошибка в подписчике:", e);
            }
        });
    }
}

=== END FILE: D:\разработка\youtube-parser-os\core\logger.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\scenario-engine.js ===

// core/scenario-engine.js
import { logger } from '../background/background.js'; // Импортируем логгер

/**
 * @typedef {import('./types/scenario.types.js').ScenarioDefinition} ScenarioDefinition
 * @typedef {import('./types/scenario.types.js').ScenarioContext} ScenarioContext
 */

export class ScenarioEngine {
    /** @type {Map<string, { definition: ScenarioDefinition, context: ScenarioContext, controller: AbortController }>} */
    #runningScenarios = new Map();

    /**
     * Регистрирует сценарий в движке.
     * @param {ScenarioDefinition} scenarioDefinition
     */
    registerScenario(scenarioDefinition) {
        // В будущем можно хранить определения для UI/выбора
        // Пока просто логируем регистрацию
        logger.debug(`[ScenarioEngine] Зарегистрирован сценарий: ${scenarioDefinition.name}`, { module: 'ScenarioEngine' });
    }

    /**
     * Запускает сценарий.
     * @param {ScenarioDefinition} scenarioDefinition
     * @param {Object} [params={}] - Параметры для сценария.
     * @param {number} [tabId] - ID вкладки, если применимо.
     * @returns {Promise<string>} ID запущенного экземпляра сценария.
     */

    async run(scenarioDefinition, params = {}, tabId = null) {
        const instanceId = this.#generateId();
        const controller = new AbortController();

        /** @type {ScenarioContext} */
        const context = {
            id: instanceId,
            tabId,
            params,
            log: (message, options = {}) => {
                logger.info(message, {
                    module: options.module || `Scenario:${scenarioDefinition.id}`,
                    contextId: instanceId,
                    ...options
                });
            },
            abortSignal: async () => {
                if (controller.signal.aborted) {
                    throw new Error('Сценарий остановлен пользователем.');
                }
            },
            controller: controller // Передаем контроллер в контекст
        };

        if (tabId) { // Убедимся, что у нас есть ID вкладки
            const abortHandler = async () => {
                logger.debug(`[ScenarioEngine] Получен сигнал отмены для сценария ${instanceId}. Уведомляем content script.`, { module: 'ScenarioEngine', contextId: instanceId });
                try {
                    // Отправляем сообщение в content script для остановки операций
                    await chrome.tabs.sendMessage(tabId, {
                        action: "abortScroll",
                        scenarioId: instanceId // Используем тот же ID
                    });
                    logger.debug(`[ScenarioEngine] Сообщение об отмене отправлено в content script для сценария ${instanceId}.`, { module: 'ScenarioEngine', contextId: instanceId });
                } catch (err) {
                    // Это нормально, если вкладка закрыта или content script не готов
                    logger.debug(`[ScenarioEngine] Не удалось отправить сообщение об отмене в content script для сценария ${instanceId}: ${err.message}`, { module: 'ScenarioEngine', contextId: instanceId });
                }
            };
            controller.signal.addEventListener('abort', abortHandler, { once: true });
            // Храним ссылку на обработчик, если нужно будет отменить подписку раньше (обычно не нужно с {once: true})
            // context._abortHandler = abortHandler; 
        }

        this.#runningScenarios.set(instanceId, { definition: scenarioDefinition, context, controller });
        // 👇 Уведомляем popup о начале сценария
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            chrome.runtime.sendMessage({
                type: "scenarioStatus",
                status: "started",
                message: `[ScenarioEngine] Запуск сценария "${scenarioDefinition.name}" (ID: ${instanceId})`,
                level: "info"
            }).catch(err => {
                console.debug("Не удалось отправить сообщение о начале сценария в popup:", err);
            });
        }

        context.log(`[ScenarioEngine] Запуск сценария "${scenarioDefinition.name}" (ID: ${instanceId})`, { module: 'ScenarioEngine' });

        try {
            await scenarioDefinition.execute(context);
            context.log(`[ScenarioEngine] Сценарий "${scenarioDefinition.name}" успешно завершен.`, { module: 'ScenarioEngine' });
        } catch (error) {
            if (error.message === 'Сценарий остановлен пользователем.') {
                context.log(`[ScenarioEngine] Сценарий "${scenarioDefinition.name}" остановлен пользователем.`, { module: 'ScenarioEngine', level: 'warn' });
            } else {
                context.log(`[ScenarioEngine] Ошибка в сценарии "${scenarioDefinition.name}": ${error.message}`, { module: 'ScenarioEngine', level: 'error' });
                logger.error(`Ошибка в сценарии "${scenarioDefinition.name}": ${error.stack}`, { module: 'ScenarioEngine', contextId: instanceId });
            }
        } finally {
            this.#runningScenarios.delete(instanceId);

            // 👇 Уведомляем popup о завершении сценария
            // Теперь мы можем получить доступ к controller через context
            const isAborted = context.controller.signal.aborted;
            const finalStatus = isAborted ? "stopped" : "finished";
            const finalMessage = isAborted ?
                `[ScenarioEngine] Сценарий "${scenarioDefinition.name}" (ID: ${instanceId}) был остановлен.` :
                `[ScenarioEngine] Сценарий "${scenarioDefinition.name}" (ID: ${instanceId}) завершен.`;

            if (typeof chrome !== 'undefined' && chrome.runtime) {
                chrome.runtime.sendMessage({
                    type: "scenarioStatus",
                    status: finalStatus,
                    message: finalMessage,
                    level: "info"
                }).catch(err => {
                    console.debug("Не удалось отправить сообщение о завершении сценария в popup:", err);
                });
            }
        }
        return instanceId;
    }

    /**
     * Останавливает запущенный сценарий.
     * @param {string} instanceId
     * @returns {boolean} true, если сценарий был найден и остановлен.
     */
    stop(instanceId) {
        const scenarioInstance = this.#runningScenarios.get(instanceId);
        if (scenarioInstance) {
            scenarioInstance.controller.abort();
            scenarioInstance.context.log(`[ScenarioEngine] Запрошена остановка сценария.`, { module: 'ScenarioEngine', level: 'warn' });
            return true;
        }
        logger.warn(`[ScenarioEngine] Попытка остановить несуществующий сценарий (ID: ${instanceId})`, { module: 'ScenarioEngine' });
        return false;
    }

    /**
     * Возвращает список запущенных сценариев.
     * @returns {Array<{id: string, name: string}>}
     */
    getRunningScenarios() {
        return Array.from(this.#runningScenarios.entries()).map(([id, { definition }]) => ({
            id,
            name: definition.name
        }));
    }

    /**
     * Генерирует уникальный ID для экземпляра сценария.
     * @returns {string}
     */
    #generateId() {
        return `scenario_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}

=== END FILE: D:\разработка\youtube-parser-os\core\scenario-engine.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\types\log.types.js ===

// core/types/log.types.js

/**
 * @typedef {Object} LogEntry
 * @property {string} id - Уникальный идентификатор записи.
 * @property {number} timestamp - Временная метка (мс с 1970).
 * @property {string} level - Уровень лога: 'debug', 'info', 'success', 'warn', 'error'.
 * @property {string} message - Текст сообщения.
 * @property {string} [module] - Модуль или компонент, создавший запись (например, 'Parser', 'Selector').
 * @property {string} [contextId] - Идентификатор контекста (например, ID сессии анализа).
 * @property {Object} [meta] - Дополнительные данные.
 */

/**
 * @typedef {Object} LoggerConfig
 * @property {number} [maxSize=1000] - Максимальное количество записей в памяти/хранилище.
 * @property {boolean} [enableConsole=true] - Дублировать логи в console.
 * @property {string} [defaultLevel='info'] - Уровень логирования по умолчанию.
 */

/**
 * @callback LogSubscriber
 * @param {LogEntry | { type: 'CLEAR_LOGS' }} entry - Запись лога или команда очистки.
 * @returns {void}
 */

/**
 * @typedef {Object} LogAdapter
 * @property {function(LogEntry): Promise<void>} write - Записывает лог.
 * @property {function(): Promise<LogEntry[]>} read - Читает все логи.
 * @property {function(): Promise<void>} clear - Очищает логи.
 */

=== END FILE: D:\разработка\youtube-parser-os\core\types\log.types.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\types\scenario.types.js ===

// core/types/scenario.types.js

/**
 * @typedef {Object} ScenarioContext
 * @property {string} id - Уникальный идентификатор выполнения сценария.
 * @property {number} [tabId] - ID активной вкладки, если применимо.
 * @property {Object} [params] - Параметры, переданные сценарию.
 * @property {function(string, Object): void} log - Функция для логирования в контексте сценария.
 * @property {function(): Promise<void>} abortSignal - Функция для проверки, не был ли запрос на остановку.
 */

/**
 * @typedef {Object} ScenarioDefinition
 * @property {string} id - Уникальный идентификатор сценария.
 * @property {string} name - Человекочитаемое имя сценария.
 * @property {string} description - Описание сценария.
 * @property {function(ScenarioContext): Promise<void>} execute - Асинхронная функция выполнения сценария.
 */

=== END FILE: D:\разработка\youtube-parser-os\core\types\scenario.types.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\types\table.types.js ===

// core/types/table.types.js

/**
 * @typedef {Object} VideoData
 * @property {string} videoId - Уникальный идентификатор видео.
 * @property {string} title - Название видео.
 * @property {string} channelName - Название канала.
 * @property {string} views - Количество просмотров (в виде строки, например, "1.2M").
 * @property {string} sourceVideoId - ID видео, с которого был совершен переход.
 * @property {string} thumbnailUrl - URL миниатюры.
 * @property {number} timestamp - Временная метка добавления записи.
 * @property {boolean} [isImported] - Флаг, указывающий, что запись была импортирована.
 */

/**
 * @typedef {Object} TableAdapter
 * @property {function(VideoData): Promise<void>} add - Добавляет одну запись.
 * @property {function(VideoData[]): Promise<void>} addBatch - Добавляет несколько записей.
 * @property {function(): Promise<VideoData[]>} getAll - Получает все записи.
 * @property {function(): Promise<void>} clear - Очищает таблицу.
 * @property {function(): Promise<number>} getCount - Получает общее количество записей.
 */

=== END FILE: D:\разработка\youtube-parser-os\core\types\table.types.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\utils\scroller.js ===

// core/utils/scroller.js
import { logger } from '../background/background.js'; // Для типов или если нужно напрямую

/**
 * Прокручивает страницу YouTube N раз с задержкой.
 * @param {Object} context - Контекст сценария для логирования. Должен содержать controller.signal.
 * @param {string} context.id - ID инстанса сценария.
 * @param {number} context.tabId - ID активной вкладки.
 * @param {AbortController} context.controller - Контроллер для отмены.
 * @param {Function} context.log - Функция логирования.
 * @param {number} [count=16] - Сколько раз скроллить.
 * @param {number} [delayMs=1500] - Задержка между скроллами (мс).
 * @param {number} [step=1000] - На сколько пикселей скроллить за раз.
 * @returns {Promise<void>}
 */
export async function scrollPageNTimes(context, count = 16, delayMs = 1500, step = 1000) {
    const { log, id: scenarioId, tabId, controller } = context;

    if (!controller || !controller.signal) {
        log(`⚠️ Контроллер отмены не найден, скроллинг не может быть остановлен.`, { module: 'Scroller', level: 'warn' });
    }

    log(`🔄 Начинаем скроллинг страницы: ${count} раз(а), шаг ${step}px, задержка ${delayMs}мс`, { module: 'Scroller' });

    try {
        // Отправляем сообщение в content script для выполнения скроллинга
        // Передаем ID сценария, чтобы content script знал, для кого сообщение об отмене
        const response = await chrome.tabs.sendMessage(tabId, {
            action: "scrollNTimes",
            scenarioId: scenarioId, // <-- Передаем ID сценария
            count: count,
            delayMs: delayMs,
            step: step
            // НЕ передаем signal
        });

        if (response && response.status === "success") {
            log(`✅ Скроллинг завершён. Обработано примерно ${response.cardCount} карточек.`, { module: 'Scroller' });
        } else if (response && response.status === "aborted") {
            log(`⏹️ Скроллинг остановлен пользователем.`, { module: 'Scroller', level: 'warn' });
            throw new Error('Скроллинг остановлен пользователем.');
        } else {
            const errorMsg = response?.message || "Неизвестная ошибка скроллинга";
            log(`❌ Ошибка скроллинга: ${errorMsg}`, { module: 'Scroller', level: 'error' });
            throw new Error(errorMsg);
        }
    } catch (err) {
        log(`❌ Ошибка при взаимодействии со страницей для скроллинга: ${err.message}`, { module: 'Scroller', level: 'error' });
        throw err;
    }
}

=== END FILE: D:\разработка\youtube-parser-os\core\utils\scroller.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\popup.css ===

/* popup/popup.css */
:root {
    --primary: #4338ca;
    --primary-hover: #3730a3;
    --success: #16a34a;
    --success-hover: #15803d;
    --warning: #ca8a04;
    --warning-hover: #a16207;
    --danger: #dc2626;
    --danger-hover: #b91c1c;
    --info: #0284c7;
    --info-hover: #0369a1;
    --secondary: #64748b;
    --secondary-hover: #475569;
    --bg: #ffffff;
    --card: #f9fafb;
    --text: #111827;
    --border: #e5e7eb;
    --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--bg);
    color: var(--text);
    padding: 16px;
    width: 800px;
    height: 720px;
    overflow: hidden;
}

.app-container {
    display: flex;
    flex-direction: column;
    gap: 16px;
    height: 100%;
    overflow: hidden;
}

.app-title {
    font-size: 20px;
    font-weight: 600;
    color: var(--primary);
    margin-bottom: 16px;
    text-align: center;
}

.section {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
    box-shadow: var(--shadow);
    flex-shrink: 0;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

#logSection .section-header {
    margin-bottom: 8px;
}

.section-title {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
}

#logSection {
    /* Позволяем секции журнала расти и сжиматься */
    flex: 1;
    /* Минимальная и максимальная высота для контроля */
    min-height: 150px;
    /* Минимальная высота, чтобы был виден хотя бы один лог */
    /* max-height: 300px; */
    /* Опционально: ограничить максимальную высоту */
    display: flex;
    flex-direction: column;
    overflow: hidden;
    /* Скрываем переполняющий контент самой секции */
}



.toggle-btn {
    background: none;
    border: none;
    font-size: 16px;
    cursor: pointer;
    color: var(--secondary);
    padding: 4px 8px;
    border-radius: 6px;
}

.toggle-btn:hover {
    background: var(--border);
}

/* Стиль для свернутого блока настроек */
.settings-section.collapsed #settingsContent {
    display: none;
}

.setting-item {
    margin-bottom: 16px;
}

.setting-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: var(--text);
}

.radio-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.radio-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 6px;
}

.radio-label:hover {
    background: var(--border);
}

.input-field {
    width: 100%;
    max-width: 200px;
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 14px;
}

.import-textarea {
    width: 100%;
    min-height: 120px;
    padding: 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-family: monospace;
    font-size: 13px;
    resize: vertical;
    margin-bottom: 12px;
}

.button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
}

.btn {
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.btn:hover {
    transform: translateY(-1px);
    box-shadow: var(--shadow);
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.btn-primary {
    background: var(--primary);
    color: white;
}

.btn-primary:hover {
    background: var(--primary-hover);
}

.btn-success {
    background: var(--success);
    color: white;
}

.btn-success:hover {
    background: var(--success-hover);
}

.btn-warning {
    background: var(--warning);
    color: white;
}

.btn-warning:hover {
    background: var(--warning-hover);
}

.btn-danger {
    background: var(--danger);
    color: white;
}

.btn-danger:hover {
    background: var(--danger-hover);
}

.btn-info {
    background: var(--info);
    color: white;
}

.btn-info:hover {
    background: var(--info-hover);
}

.btn-secondary {
    background: var(--secondary);
    color: white;
}

.btn-secondary:hover {
    background: var(--secondary-hover);
}

/* Журнал */
.log-container {
    padding: 12px;
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
    background: white;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.5;
}

.log-entry {
    padding: 6px 0;
    border-bottom: 1px solid var(--border);
    font-family: monospace;
}

.log-entry:last-child {
    border-bottom: none;
}

.log-level-info {
    color: var(--text);
}

.log-level-success {
    color: var(--success);
    font-weight: 500;
}

.log-level-warn {
    color: var(--warning);
}

.log-level-error {
    color: var(--danger);
    font-weight: 500;
}

/* Placeholder для журнала */
.log-placeholder {
    color: var(--secondary);
    font-style: italic;
    text-align: center;
    padding: 20px 0;
}

#tableSection {
    /* Позволяем секции таблицы тоже расти и сжиматься, но с меньшим приоритетом */
    flex: 2;
    /* Минимальная высота */
    min-height: 150px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    /* Скрываем переполняющий контент самой секции */
}

#tableSection .section-header {
    margin-bottom: 8px;
}

/* Таблица */
.table-container {
    flex: 1;
    overflow: auto;
    min-height: 0;
    border: 1px solid var(--border);
    border-radius: 8px;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    height: 100%;
}

.data-table th,
.data-table td {
    padding: 8px;
    text-align: left;
    border: 1px solid var(--border);
}

.data-table th {
    background-color: var(--card);
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 1;
}

.data-table tr:nth-child(even) {
    background-color: #fafafa;
}

/* Placeholder для таблицы */
.table-placeholder td {
    text-align: center;
    color: var(--secondary);
    font-style: italic;
    padding: 40px 20px;
}

.data-table img {
    width: 60px;
    height: 34px;
    object-fit: cover;
    border-radius: 4px;
}

/* Скроллбары */
.log-container::-webkit-scrollbar,
.table-container::-webkit-scrollbar {
    width: 6px;
}

.log-container::-webkit-scrollbar-thumb,
.table-container::-webkit-scrollbar-thumb {
    background-color: var(--border);
    border-radius: 3px;
}

=== END FILE: D:\разработка\youtube-parser-os\popup\popup.css ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\popup.html ===

<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Рекомендации Парсер</title>
    <link rel="stylesheet" href="popup.css">
</head>

<body>
    <div class="app-container">
        <header class="app-header">
            <h1 class="app-title">📹 YouTube Рекомендации Парсер</h1>
        </header>

        <!-- Настройки (Collapsible) -->
        <section id="settingsSection" class="section settings-section">
            <div class="section-header">
                <h2 class="section-title">⚙️ Настройки</h2>
                <button id="toggleSettingsBtn" class="toggle-btn">▲</button>
            </div>
            <div id="settingsContent" class="section-content">
                <!-- Алгоритм выбора -->
                <div class="setting-item">
                    <label class="setting-label">Алгоритм выбора следующего видео:</label>
                    <div class="radio-group">
                        <!-- Изменяем текст и value -->
                        <label class="radio-label">
                            <input type="radio" name="selectionMode" value="all_videos" checked>
                            Анализ всех видео
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="selectionMode" value="current_recommendations">
                            Анализ видео из последней подборки
                        </label>
                    </div>
                </div>

                <!-- Количество итераций -->
                <div class="setting-item">
                    <label class="setting-label" for="iterationsInput">Количество итераций:</label>
                    <input type="number" id="iterationsInput" class="input-field" value="10" min="1" max="1000">
                </div>

                <!-- Импорт данных -->
                <div class="setting-item">
                    <label class="setting-label">Импорт данных (CSV/TSV):</label>
                    <textarea id="importTextarea" class="import-textarea"
                        placeholder="Вставьте данные... Название,ID,Просмотры,Канал,Исходное видео,Миниатюра"></textarea>
                    <div class="button-group">
                        <button id="importDataBtn" class="btn btn-primary">📂 Загрузить данные</button>
                        <button id="clearImportedBtn" class="btn btn-secondary">🗑️ Очистить импортированные</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Управление -->
        <section id="controlSection" class="section control-section">
            <div class="section-header">
                <h2 class="section-title">🎛️ Управление</h2>
            </div>
            <div class="control-group">
                <!-- Выпадающий список сценариев -->
                <div class="setting-item">
                    <label class="setting-label" for="scenarioSelector">Выберите сценарий:</label>
                    <select id="scenarioSelector" class="input-field">
                        <option value="parse-recommendation">Парсинг рекомендаций</option>
                        <option value="test-countdown">Тестовый сценарий: Обратный отсчет</option>
                        <!-- В будущем можно добавить больше опций -->
                    </select>
                </div>

                <!-- Кнопки управления -->
                <div class="button-group">
                    <!-- Изменяем ID и текст кнопки запуска -->
                    <button id="runScenarioBtn" class="btn btn-success">▶️ Запустить сценарий</button>
                    <!-- Кнопка остановки, как и раньше -->
                    <button id="stopBtn" class="btn btn-warning" disabled>⏹️ Остановить</button>
                    <button id="copyTableBtn" class="btn btn-info">📋 Копировать таблицу</button>
                    <button id="clearTableBtn" class="btn btn-danger">🗑️ Очистить таблицу</button>
                    <button id="clearLogBtn" class="btn btn-secondary">🧹 Очистить журнал</button>
                </div>
            </div>
        </section>

        <!-- Журнал событий -->
        <section id="logSection" class="section log-section">
            <div class="section-header">
                <h2 class="section-title">📋 Журнал событий</h2>
            </div>
            <div id="logContainer" class="log-container">
                <!-- Логи будут вставляться сюда -->
                <div class="log-placeholder">Журнал пуст</div>
            </div>
        </section>

        <!-- Таблица данных -->
        <section id="tableSection" class="section table-section">
            <div class="section-header">
                <h2 class="section-title">📊 Спарсенные данные</h2>
            </div>
            <div class="table-container">
                <table id="dataTable" class="data-table">
                    <thead>
                        <tr>
                            <th>Название</th>
                            <th>ID</th>
                            <th>Просмотры</th>
                            <th>Канал</th>
                            <th>Исходное видео</th>
                            <th>Миниатюра</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Данные будут вставляться сюда -->
                        <tr class="table-placeholder">
                            <td colspan="6">Таблица пуста</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
    </div>

    <script type="module" src="./popup.js"></script>
</body>

</html>

=== END FILE: D:\разработка\youtube-parser-os\popup\popup.html ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\popup.js ===

// popup/popup.js
import { SettingsSection } from './components/SettingsSection.js';
import { ControlSection } from './components/ControlSection.js';
import { LogSection } from './components/LogSection.js';
import { TableSection } from './components/TableSection.js';

class PopupApp {
    constructor() {
        this.isScenarioLaunchInProgress = false; // Флаг для защиты от повторных кликов
        this.initElements();
        // Переносим bindEvents ближе к началу, или добавляем критичные слушатели сразу
        this.bindCriticalEventListeners(); // <-- Добавляет 'runScenario' listener
        this.initComponents(); // Создает ControlSection
        // this.bindEvents(); // Остальные обработчики можно оставить здесь или вызвать после
        this.loadState();
        this.updateScenarioControlButtons(false);
        this.checkScenarioStatusOnLoad();
        // Убедиться, что все остальные обработчики тоже добавлены
        this.bindEvents();
    }

    bindCriticalEventListeners() {
        // Добавляем критически важные слушатели CustomEvent как можно раньше
        console.log("[PopupApp] Добавляем критичный слушатель CustomEvent 'runScenario'");
        // Убедитесь, что этот обработчик добавляется ТОЛЬКО ЗДЕСЬ и НИГДЕ БОЛЬШЕ
        document.addEventListener('runScenario', () => {
            console.log("[PopupApp] Получено CustomEvent 'runScenario', вызываем handleRunScenario");
            this.handleRunScenario();
        });
        // Добавьте сюда и другие критичные слушатели, если есть
    }

    initElements() {
        // Инициализируем ссылки на DOM элементы, принадлежащие popup напрямую
        this.settingsSection = document.getElementById('settingsSection');
        this.settingsContent = document.getElementById('settingsContent');
        this.toggleSettingsBtn = document.getElementById('toggleSettingsBtn');

        this.selectionModeRadios = document.querySelectorAll('input[name="selectionMode"]');
        this.iterationsInput = document.getElementById('iterationsInput');
        this.importTextarea = document.getElementById('importTextarea');
        this.importDataBtn = document.getElementById('importDataBtn');
        this.clearImportedBtn = document.getElementById('clearImportedBtn');

        this.runScenarioBtn = document.getElementById('runScenarioBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.copyTableBtn = document.getElementById('copyTableBtn');
        this.clearTableBtn = document.getElementById('clearTableBtn');
        this.clearLogBtn = document.getElementById('clearLogBtn');

        // Элемент для нового функционала
        this.scenarioSelector = document.getElementById('scenarioSelector');

        document.addEventListener('importData', (e) => {
            this.handleImportData(e.detail); // Передаём detail как аргумент
        });
    }

    initComponents() {
        // Создаём экземпляры компонентов. Они сами привяжут свои обработчики и DOM.
        this.settings = new SettingsSection();
        this.control = new ControlSection();
        this.logs = new LogSection();
        this.table = new TableSection();

        // Инициируем загрузку начальных данных для компонентов
        // Это заменяет старые updateLogs и updateTable
        this.logs.loadInitialLogs();
        this.table.loadInitialData();
    }

    bindEvents() {
        // --- Обработчики UI popup-а ---
        this.selectionModeRadios.forEach(radio => {
            radio.addEventListener('change', () => this.saveSettings());
        });
        console.log("[PopupApp] Добавляем слушатель CustomEvent 'runScenario'");
        this.iterationsInput.addEventListener('change', () => this.saveSettings());
        this.importDataBtn.addEventListener('click', () => this.handleImport());
        this.clearImportedBtn.addEventListener('click', () => this.handleClearImported());

        this.runScenarioBtn.addEventListener('click', () => this.handleRunScenario());
        this.stopBtn.addEventListener('click', () => this.handleStop());
        this.copyTableBtn.addEventListener('click', () => this.handleCopyTable());
        this.clearTableBtn.addEventListener('click', () => this.handleClearTable());
        this.clearLogBtn.addEventListener('click', () => this.handleClearLog());
        // --- Слушатель сообщений от background ---
        this.addMessageListener();


    }

    // --- State Management ---
    saveSettings() {

        // Определяем состояние для сохранения
        const isSettingsCollapsed = this.settingsSection.classList.contains('collapsed');

        const state = {
            isSettingsCollapsed: isSettingsCollapsed,
            selectionMode: document.querySelector('input[name="selectionMode"]:checked')?.value || 'smart',
            iterations: this.iterationsInput.value,
        };


        try {
            localStorage.setItem('popupSettings', JSON.stringify(state));
        } catch (e) {
            console.error("saveSettings: Ошибка при сохранении в localStorage:", e);
        }
    }

    loadState() {

        const savedStateJson = localStorage.getItem('popupSettings');
        if (savedStateJson) {
            try {
                const state = JSON.parse(savedStateJson);
                if (state.isSettingsCollapsed === true) {
                    this.settingsSection.classList.add('collapsed');
                    this.toggleSettingsBtn.textContent = '🔽';
                } else {
                    this.settingsSection.classList.remove('collapsed');
                    this.toggleSettingsBtn.textContent = '▲';
                }

                // Применяем другие настройки (если есть)
                if (state.selectionMode) {
                    const radio = document.querySelector(`input[name="selectionMode"][value="${state.selectionMode}"]`);
                    if (radio) {
                        radio.checked = true;
                    }
                }

                if (state.iterations) {
                    this.iterationsInput.value = state.iterations;
                }
            } catch (e) {
                console.error("loadState: Ошибка при парсинге сохранённого состояния:", e);
                // В случае ошибки парсинга, используем значения по умолчанию
                // и пересохраняем их
            }
        } else {
            this.settingsSection.classList.remove('collapsed'); // По умолчанию развернуто
            this.toggleSettingsBtn.textContent = '▲';
            // Другие значения по умолчанию уже заданы в HTML
        }
    }

    // --- Message Listener ---
    addMessageListener() {
        this.messageListener = (request, sender, sendResponse) => {
            if (request.type === 'dataUpdated') {
                this.table.loadInitialData();
            }

            if (request.type === 'dataCleared') {
                document.dispatchEvent(new CustomEvent('clearTable'));
            }

            if (request.type === 'newLog' && request.log) {
                document.dispatchEvent(new CustomEvent('log', { detail: request.log }));
            }

            if (request.type === 'logsCleared') {
                document.dispatchEvent(new CustomEvent('clearLog'));
            }

            if (request.type === 'dataCleared') {
                document.dispatchEvent(new CustomEvent('clearTable'));
            }

            if (request.type === 'scenarioStatus') {
                console.log("PopupApp: Received scenarioStatus message", request);
                if (request.status === 'started') {
                    this.updateScenarioControlButtons(true);
                } else if (request.status === 'stopped' || request.status === 'finished') {
                    this.updateScenarioControlButtons(false);
                }
                // Логируем сообщение от сценария, если оно есть
                if (request.message) {
                    document.dispatchEvent(new CustomEvent('log', { detail: { message: request.message, level: request.level || 'info' } }));
                }
            }

        };

        chrome.runtime.onMessage.addListener(this.messageListener);
    }

    // --- Button Handlers (имитация / заглушки) ---
    // Эти обработчики теперь используют CustomEvent для взаимодействия с компонентами
    // или напрямую вызывают chrome.runtime.sendMessage

    handleImport() {
        const text = this.importTextarea.value.trim();
        if (!text) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: '❌ Нет данных для импорта', level: 'error' } }));
            return;
        }
        document.dispatchEvent(new CustomEvent('log', { detail: { message: `✅ Импорт данных (имитация): ${text.split('\n').length - 1} строк`, level: 'success' } }));
        this.importTextarea.value = '';
        // В реальном сценарии здесь будет sendMessage для импорта в background
        // и затем событие обновления таблицы
        setTimeout(() => {
            this.table.loadInitialData(); // Имитация обновления таблицы
        }, 500);
    }

    handleClearImported() {
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Импортированные данные очищены (имитация)', level: 'success' } }));
        // В реальном сценарии здесь будет sendMessage для очистки в background
    }

    async handleRunScenario() {
        console.log("[PopupApp] handleRunScenario начал выполнение, isScenarioLaunchInProgress:", this.isScenarioLaunchInProgress);

        // Защита от повторных кликов
        if (this.isScenarioLaunchInProgress) {
            console.warn("[PopupApp] Запуск сценария уже выполняется, игнорируем клик.");
            document.dispatchEvent(new CustomEvent('log', {
                detail: { message: 'ℹ️ Запуск сценария уже выполняется, подождите.', level: 'warn' }
            }));
            return;
        }

        try {
            // 👇 НОВОЕ: Проверяем статус перед запуском с расширенной отладкой
            console.log("[PopupApp] handleRunScenario: начинаем проверку статуса сценариев...");

            // 1. Логируем сам объект сообщения
            const getStatusMessage = { action: "getScenarioStatus" };
            console.log("[PopupApp] handleRunScenario: подготавливаем сообщение для отправки:", getStatusMessage);

            // 2. Логируем начало отправки
            console.log("[PopupApp] handleRunScenario: вызываем chrome.runtime.sendMessage...");
            let statusResponse;
            let sendMessageError = null;

            try {
                statusResponse = await chrome.runtime.sendMessage(getStatusMessage);
                console.log("[PopupApp] handleRunScenario: ОТПРАВКА СООБЩЕНИЯ УСПЕШНА, получаем ответ...");
            } catch (err) {
                sendMessageError = err;
                console.error("[PopupApp] handleRunScenario: ПОЙМАНА ОШИБКА ПРИ ОТПРАВКЕ СООБЩЕНИЯ:", err);
                console.error("[PopupApp] handleRunScenario: stack trace ошибки отправки:", err?.stack);
            }

            // 3. Проверяем результат
            if (sendMessageError) {
                console.error("[PopupApp] handleRunScenario: ошибка отправки сообщения getScenarioStatus, прерываем запуск.");
                document.dispatchEvent(new CustomEvent('log', {
                    detail: { message: `❌ Ошибка связи при проверке статуса: ${sendMessageError.message}`, level: 'error' }
                }));
                // Можно выбросить ошибку, чтобы она попала в общий catch
                throw sendMessageError;
            }

            console.log("[PopupApp] handleRunScenario: ответ на проверку статуса (сырой):", statusResponse);

            // 4. Проверяем формат ответа
            if (!statusResponse) {
                console.warn("[PopupApp] handleRunScenario: ответ от background.js пустой или undefined.");
                document.dispatchEvent(new CustomEvent('log', {
                    detail: { message: '⚠️ Получен пустой ответ от background.js при проверке статуса.', level: 'warn' }
                }));
                // Можно продолжить или прервать, решим позже
            } else if (typeof statusResponse !== 'object') {
                console.warn("[PopupApp] handleRunScenario: ответ от background.js не является объектом:", typeof statusResponse, statusResponse);
                document.dispatchEvent(new CustomEvent('log', {
                    detail: { message: '⚠️ Получен неожиданный формат ответа от background.js при проверке статуса.', level: 'warn' }
                }));
            }

            if (statusResponse?.status === "success" && statusResponse.isRunning) {
                console.warn("[PopupApp] Сценарий уже запущен, запуск отменен.");
                document.dispatchEvent(new CustomEvent('log', {
                    detail: {
                        message: 'ℹ️ Сценарий уже запущен. Остановите текущий перед запуском нового.',
                        level: 'warn'
                    }
                }));
                return; // Просто выходим, не устанавливая флаг
            }
            console.log("[PopupApp] handleRunScenario: проверка статуса пройдена.");
            // 👆 НОВОЕ (расширенная отладка)

            // Устанавливаем флаг только после всех проверок
            this.isScenarioLaunchInProgress = true;
            console.log("[PopupApp] handleRunScenario: флаг isScenarioLaunchInProgress установлен в true.");

            // ... (остальной код функции без изменений, добавим логи и туда) ...

            // 1. Получаем ID выбранного сценария
            const selectedScenarioId = this.scenarioSelector.value;
            console.log("[PopupApp] handleRunScenario: selectedScenarioId =", selectedScenarioId);
            if (!selectedScenarioId) {
                console.log("[PopupApp] handleRunScenario: сценарий не выбран, отправляем лог об ошибке.");
                document.dispatchEvent(new CustomEvent('log', { detail: { message: '❌ Не выбран сценарий для запуска', level: 'error' } }));
                this.isScenarioLaunchInProgress = false; // Сбросим флаг
                return;
            }

            // 2. Получаем параметры из UI
            const iterations = parseInt(this.iterationsInput.value) || 10;
            const mode = document.querySelector('input[name="selectionMode"]:checked')?.value || 'all_videos';
            console.log("[PopupApp] handleRunScenario: параметры получены: iterations =", iterations, ", mode =", mode);

            // 3. Логируем начало
            const scenarioName = this.scenarioSelector.options[this.scenarioSelector.selectedIndex].text;
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `📤 Запуск сценария "${scenarioName}": ${iterations} итераций, режим: ${mode}`, level: 'info' } }));
            console.log("[PopupApp] handleRunScenario: отправлен лог о начале запуска.");

            // 4. Отправляем сообщение в background с параметрами
            console.log("[PopupApp] handleRunScenario: отправляем сообщение runScenario в background...");
            const runMessage = {
                action: "runScenario",
                scenarioId: selectedScenarioId,
                params: {
                    iterations,
                    mode,
                    count: 16,
                    delayMs: 1500,
                    step: 1000
                }
            };
            console.log("[PopupApp] handleRunScenario: сообщение для запуска:", runMessage);

            let runResponse;
            let runSendMessageError = null;
            try {
                runResponse = await chrome.runtime.sendMessage(runMessage);
                console.log("[PopupApp] handleRunScenario: ОТПРАВКА СООБЩЕНИЯ ЗАПУСКА УСПЕШНА, получаем ответ...");
            } catch (err) {
                runSendMessageError = err;
                console.error("[PopupApp] handleRunScenario: ПОЙМАНА ОШИБКА ПРИ ОТПРАВКЕ СООБЩЕНИЯ ЗАПУСКА:", err);
                console.error("[PopupApp] handleRunScenario: stack trace ошибки отправки запуска:", err?.stack);
            }

            if (runSendMessageError) {
                console.error("[PopupApp] handleRunScenario: ошибка отправки сообщения runScenario, обрабатываем.");
                document.dispatchEvent(new CustomEvent('log', {
                    detail: { message: `❌ Ошибка связи при запуске сценария: ${runSendMessageError.message}`, level: 'error' }
                }));
                this.updateScenarioControlButtons(false);
                this.isScenarioLaunchInProgress = false;
                throw runSendMessageError; // Пробрасываем для общего catch
            }

            console.log("[PopupApp] handleRunScenario: ответ на запуск (сырой):", runResponse);

            if (runResponse && runResponse.status === "started") {
                console.log("[PopupApp] Сценарий успешно запущен в background, обновляем состояние кнопок.");
                // 5. Обновляем состояние кнопок
                this.updateScenarioControlButtons(true);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `✅ Сценарий запущен. ID: ${runResponse.instanceId}`, level: 'success' } }));
                console.log("[PopupApp] handleRunScenario: кнопки обновлены, лог об успехе отправлен.");
            } else {
                const errorMsg = runResponse?.message || 'Неизвестная ошибка при запуске';
                console.error("[PopupApp] Ошибка запуска сценария:", errorMsg);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка запуска сценария: ${errorMsg}`, level: 'error' } }));
                // Возвращаем кнопки в исходное состояние в случае ошибки
                this.updateScenarioControlButtons(false);
                this.isScenarioLaunchInProgress = false; // Сбросим флаг
            }

        } catch (err) {
            // Этот блок теперь поймает и ошибки send, и другие ошибки
            console.error("[PopupApp] Исключение в handleRunScenario (общий catch):", err);
            console.error("[PopupApp] Исключение в handleRunScenario (общий catch), stack:", err?.stack);
            document.dispatchEvent(new CustomEvent('log', {
                detail: { message: `❌ Критическая ошибка при запуске сценария: ${err.message}`, level: 'error' }
            }));
            // Возвращаем кнопки в исходное состояние в случае ошибки
            this.updateScenarioControlButtons(false);
            this.isScenarioLaunchInProgress = false; // Сбросим флаг
        }
    }

    async handleStop() {
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '📤 Отправка команды на остановку всех сценариев...', level: 'info' } }));

        try {
            // Отправляем сообщение в background для остановки всех сценариев
            const response = await chrome.runtime.sendMessage({
                action: "stopAllScenarios"
            });

            if (response && response.status === "success") {
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `✅ ${response.message}`, level: 'warn' } }));
                // Обновляем состояние кнопок
                this.updateScenarioControlButtons(false);
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка при остановке';
                console.error("[PopupApp] Ошибка остановки сценариев:", errorMsg);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка остановки сценариев: ${errorMsg}`, level: 'error' } }));
                // Оставляем кнопки в состоянии "запущено", так как остановка не удалась
            }
        } catch (err) {
            console.error("[PopupApp] Исключение при остановке сценариев:", err);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка связи при остановке сценариев: ${err.message}`, level: 'error' } }));
            // Оставляем кнопки в состоянии "запущено", так как остановка не удалась
        }
    }

    async handleCopyTable() {
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '📤 Подготовка таблицы для копирования...', level: 'info' } }));
        try {
            const response = await chrome.runtime.sendMessage({ action: "copyTableData" });
            if (response.status === "success") {
                await navigator.clipboard.writeText(response.data);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Таблица скопирована в буфер обмена', level: 'success' } }));
            } else {
                throw new Error(response.message);
            }
        } catch (err) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка копирования таблицы: ${err.message}`, level: 'error' } }));
        }
    }

    async handleClearTable() {
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '📤 Отправка команды на очистку таблицы...', level: 'info' } }));
        try {
            const response = await chrome.runtime.sendMessage({ action: "clearTableData" });
            if (response.status === "success") {
                document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Таблица очищена', level: 'success' } }));
                // Сообщаем TableSection об очистке
                document.dispatchEvent(new CustomEvent('clearTable'));
            } else {
                throw new Error(response.message);
            }
        } catch (err) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка очистки таблицы: ${err.message}`, level: 'error' } }));
        }
    }

    async handleClearLog() {
        // В реальном сценарии popup отправляет сообщение в background для очистки
        // и background потом прислает 'logsCleared' или popup сам обновит UI
        try {
            await chrome.storage.local.remove(['appLogs']);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Журнал очищен', level: 'success' } }));
            // Сообщаем компоненту журнала об очистке
            document.dispatchEvent(new CustomEvent('clearLog'));
        } catch (err) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка очистки журнала: ${err.message}`, level: 'error' } }));
        }
    }

    async handleImportData(eventDetail) {
        const dataToImport = eventDetail && eventDetail.data;

        if (!dataToImport || !Array.isArray(dataToImport)) {
            console.error("[PopupApp] handleImportData: данные отсутствуют или не являются массивом", dataToImport);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: '❌ Ошибка: Некорректные данные для импорта', level: 'error' } }));
            return;
        }

        document.dispatchEvent(new CustomEvent('log', { detail: { message: `📤 Отправка ${dataToImport.length} записей для импорта...`, level: 'info' } }));

        try {
            // Отправляем данные в background для сохранения
            const response = await chrome.runtime.sendMessage({
                action: "importTableData", // Новое сообщение для обработки импорта
                data: dataToImport // Отправляем массив напрямую
            });

            if (response && response.status === "success") {
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `✅ ${response.count} записей успешно импортированы`, level: 'success' } }));
                // Принудительно обновляем таблицу в popup
                this.table.loadInitialData();
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка';
                console.error("[PopupApp] Ошибка импорта в background:", errorMsg);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка импорта: ${errorMsg}`, level: 'error' } }));
            }
        } catch (err) {
            console.error("[PopupApp] Ошибка отправки данных в background:", err);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка связи с background: ${err.message}`, level: 'error' } }));
        }
    }

    /**
     * Обновляет состояние кнопок управления сценариями.
     * @param {boolean} isRunning - Запущен ли сейчас какой-либо сценарий.
     */
    updateScenarioControlButtons(isRunning) {
        if (this.runScenarioBtn && this.stopBtn) {
            this.runScenarioBtn.disabled = isRunning;
            this.stopBtn.disabled = !isRunning;
        }
    }

    /**
     * Проверяет статус выполнения сценариев при загрузке popup.
     * Обновляет состояние кнопок управления соответственно.
     */
    async checkScenarioStatusOnLoad() {
        console.log("[PopupApp] Проверка статуса сценариев при загрузке...");
        try {
            const response = await chrome.runtime.sendMessage({
                action: "getScenarioStatus"
            });

            if (response && response.status === "success") {
                const isRunning = response.isRunning;
                console.log(`[PopupApp] Статус сценариев при загрузке: isRunning=${isRunning}`);

                // 👇 ВАЖНО: Сбрасываем флаг запуска, так как проверка статуса завершена
                // Это исправит ситуацию, если флаг завис после закрытия popup
                this.isScenarioLaunchInProgress = false;

                this.updateScenarioControlButtons(isRunning);

                if (isRunning) {
                    const count = response.runningScenarios?.length || 1;
                    document.dispatchEvent(new CustomEvent('log', {
                        detail: {
                            message: `ℹ️ При загрузке popup обнаружено запущенных сценариев: ${count}. Кнопка "Остановить" активна.`,
                            level: 'info'
                        }
                    }));
                }
            } else {
                console.warn("[PopupApp] Не удалось получить статус сценариев при загрузке:", response?.message);
                // Сбрасываем флаг и кнопки в начальное состояние
                this.isScenarioLaunchInProgress = false;
                this.updateScenarioControlButtons(false);
            }
        } catch (err) {
            console.error("[PopupApp] Ошибка при проверке статуса сценариев при загрузке:", err);
            // Сбрасываем флаг и кнопки в начальное состояние
            this.isScenarioLaunchInProgress = false;
            this.updateScenarioControlButtons(false);
        }
    }
}

// Запускаем приложение
document.addEventListener('DOMContentLoaded', () => {
    new PopupApp();
});

=== END FILE: D:\разработка\youtube-parser-os\popup\popup.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\components\ControlSection.js ===

// popup/components/ControlSection.js

export class ControlSection {
    constructor() {
        // Обновляем ID элементов в соответствии с popup.html
        this.runScenarioBtn = document.getElementById('runScenarioBtn'); // <-- Изменено
        this.stopBtn = document.getElementById('stopBtn');
        this.copyTableBtn = document.getElementById('copyTableBtn');
        this.clearTableBtn = document.getElementById('clearTableBtn');
        this.clearLogBtn = document.getElementById('clearLogBtn');

        // Добавляем ссылку на селектор сценариев
        this.scenarioSelector = document.getElementById('scenarioSelector'); // <-- Новое

        this.init();
    }

    init() {
        // Слушаем внутренние события от popup контроллера (если используются)
        // document.addEventListener('control:enableStart', () => this.enableStart());
        // document.addEventListener('control:disableStart', () => this.disableStart());

        // Привязываем обработчики событий UI
        // ОСНОВНОЕ ИЗМЕНЕНИЕ ЗДЕСЬ:
        // НЕ добавляем обработчик клика напрямую на this.runScenarioBtn.
        // Эта кнопка будет обрабатываться через CustomEvent в PopupApp.

        // Если в ControlSection есть bindEvents, убедитесь, что в нем
        // тоже нет строки вроде:
        // if (this.runScenarioBtn) {
        //   this.runScenarioBtn.addEventListener('click', ...);
        // }

        // Можно добавить лог для отладки, что сам элемент найден:
        if (!this.runScenarioBtn) {
            console.error("[ControlSection] Кнопка 'runScenarioBtn' не найдена в DOM при инициализации!");
        } else {
            console.log("[ControlSection] Кнопка 'runScenarioBtn' успешно найдена.");
        }

        console.log("[ControlSection] Инициализирован. Элементы:", {
            runScenarioBtn: this.runScenarioBtn,
            stopBtn: this.stopBtn,
            copyTableBtn: this.copyTableBtn,
            clearTableBtn: this.clearTableBtn,
            clearLogBtn: this.clearLogBtn,
            scenarioSelector: this.scenarioSelector
        });
    }

    // Методы enableStart/disableStart могут быть не нужны, если состояние кнопок управляется напрямую из PopupApp
    // Но оставим их для совместимости или будущего использования
    // Обновим их, чтобы они работали с правильным ID кнопки
    enableRunButton() { // <-- Имя метода обновлено для ясности
        if (this.runScenarioBtn) this.runScenarioBtn.disabled = false;
    }

    disableRunButton() { // <-- Имя метода обновлено для ясности
        if (this.runScenarioBtn) this.runScenarioBtn.disabled = true;
    }

    // Остальные методы handle* были перенесены в PopupApp.js
    // Этот компонент теперь в основном отвечает за хранение ссылок на элементы
    // и, при необходимости, управление их состоянием напрямую или через методы.

    dispatchEvent(type, detail) {
        document.dispatchEvent(new CustomEvent(type, { detail }));
    }
}


=== END FILE: D:\разработка\youtube-parser-os\popup\components\ControlSection.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\components\LogSection.js ===

// popup/components/LogSection.js
export class LogSection {
    constructor() {
        this.container = document.getElementById('logContainer');
        this.init();
    }

    init() {
        // Слушаем внутренние события для добавления логов
        document.addEventListener('log', (e) => {
            this.addLog(e.detail);
        });
        document.addEventListener('clearLog', () => this.clear());
        // При инициализации сразу загружаем начальные логи
        this.loadInitialLogs();
    }

    /**
     * Загружает и отображает начальные логи из хранилища.
     */
    async loadInitialLogs() {
        try {
            // Получаем логи напрямую из chrome.storage.local
            // В будущем это можно будет заменить на вызов нового Logger API
            const result = await chrome.storage.local.get(['appLogs']);
            const logs = result.appLogs || [];

            // Очищаем контейнер и убираем placeholder
            this.container.innerHTML = '';

            if (logs.length === 0) {
                // Если логов нет, показываем placeholder
                this.#showPlaceholder();
            } else {
                // Отображаем последние N логов, например, последние 100
                const logsToShow = logs.slice(-100);
                logsToShow.forEach(logEntry => {
                    // Используем существующий метод addLog, но без прокрутки
                    this.#renderLogEntry(logEntry);
                });
                // Прокручиваем вниз только один раз, после добавления всех начальных логов
                this.container.scrollTop = this.container.scrollHeight;
            }
        } catch (error) {
            console.error("LogSection: Ошибка при загрузке начальных логов:", error);
            // Даже в случае ошибки показываем placeholder
            this.#showPlaceholder();
            // Можно также залогировать ошибку в UI
            this.addLog({ message: `⚠️ Ошибка загрузки журнала: ${error.message}`, level: 'error' });
        }
    }

    /**
     * Добавляет запись в журнал событий, учитывая позицию прокрутки пользователя.
     * @param {Object} logEntry - Объект записи лога.
     * @param {string} logEntry.message - Текст сообщения.
     * @param {string} logEntry.level - Уровень лога ('info', 'success', 'warn', 'error').
     * @param {number} logEntry.timestamp - Временная метка.
     */
    addLog({ message, level = 'info', timestamp = Date.now() }) {
        // Удаляем placeholder, если он есть
        const placeholder = this.container.querySelector('.log-placeholder');
        if (placeholder) {
            placeholder.remove();
        }

        const entry = document.createElement('div');
        entry.className = `log-entry log-level-${level}`;
        const time = new Date(timestamp).toLocaleTimeString();
        entry.textContent = `[${time}] ${message}`;

        // --- Логика умной прокрутки ---
        const container = this.container;
        const isScrolledToBottom = (container.scrollHeight - container.clientHeight) <= (container.scrollTop + 1);
        container.appendChild(entry);
        if (isScrolledToBottom) {
            container.scrollTop = container.scrollHeight;
        }
        // ---
    }

    /**
     * Очищает журнал и показывает placeholder.
     */
    clear() {
        this.container.innerHTML = '';
        this.#showPlaceholder();
        // Опционально: можно залогировать факт очистки
        // this.addLog({ message: '🧹 Журнал очищен', level: 'info' });
    }

    // --- Вспомогательные методы ---

    /**
     * Показывает placeholder "Журнал пуст".
     */
    #showPlaceholder() {
        const placeholder = document.createElement('div');
        placeholder.className = 'log-placeholder';
        placeholder.textContent = 'Журнал пуст';
        this.container.appendChild(placeholder);
    }

    /**
     * Внутренний метод для рендеринга одной записи без логики прокрутки.
     * Используется при загрузке начальных логов.
     * @private
     */
    #renderLogEntry({ message, level = 'info', timestamp = Date.now() }) {
        // Placeholder удаляется первой записью
        const placeholder = this.container.querySelector('.log-placeholder');
        if (placeholder) {
            placeholder.remove();
        }

        const entry = document.createElement('div');
        entry.className = `log-entry log-level-${level}`;
        const time = new Date(timestamp).toLocaleTimeString();
        entry.textContent = `[${time}] ${message}`;
        this.container.appendChild(entry);
        // Прокрутка НЕ происходит здесь
    }
}

=== END FILE: D:\разработка\youtube-parser-os\popup\components\LogSection.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\components\SettingsSection.js ===

export class SettingsSection {
    constructor() {
        this.element = document.getElementById('settingsSection');
        this.toggleBtn = document.getElementById('toggleSettingsBtn');
        this.selectionModeRadios = document.querySelectorAll('input[name="selectionMode"]');
        this.iterationsInput = document.getElementById('iterationsInput');
        this.importTextarea = document.getElementById('importTextarea');
        this.importDataBtn = document.getElementById('importDataBtn');
        this.clearImportedBtn = document.getElementById('clearImportedBtn');

        this.init();
    }

    init() {
        // Восстанавливаем состояние из localStorage
        this.restoreState();

        // Обработчики
        this.toggleBtn.addEventListener('click', () => this.toggle());
        this.selectionModeRadios.forEach(radio => {
            radio.addEventListener('change', () => this.saveState());
        });
        this.iterationsInput.addEventListener('change', () => this.saveState());
        this.importDataBtn.addEventListener('click', () => this.handleImport());
        this.clearImportedBtn.addEventListener('click', () => this.handleClearImported());

        // Сохраняем при потере фокуса
        this.iterationsInput.addEventListener('blur', () => this.saveState());
    }

    toggle() {
        const isCollapsed = this.element.classList.contains('collapsed');
        if (isCollapsed) {
            this.expand();
        } else {
            this.collapse();
        }
        this.saveState();
    }

    collapse() {
        this.element.classList.add('collapsed');
        this.toggleBtn.textContent = '🔽';
    }

    expand() {
        this.element.classList.remove('collapsed');
        this.toggleBtn.textContent = '▲';
    }

    saveState() {
        const state = {
            isCollapsed: this.element.classList.contains('collapsed'),
            selectionMode: document.querySelector('input[name="selectionMode"]:checked')?.value || 'smart',
            iterations: this.iterationsInput.value,
        };
        localStorage.setItem('settingsState', JSON.stringify(state));
    }

    restoreState() {
        const saved = localStorage.getItem('settingsState');
        if (saved) {
            const state = JSON.parse(saved);
            if (state.isCollapsed) {
                this.collapse();
            } else {
                this.expand();
            }
            if (state.selectionMode) {
                const radio = document.querySelector(`input[name="selectionMode"][value="${state.selectionMode}"]`);
                if (radio) radio.checked = true;
            }
            if (state.iterations) {
                this.iterationsInput.value = state.iterations;
            }
        }
    }

    handleImport() {
        const text = this.importTextarea.value.trim();

        if (!text) {
            this.dispatchEvent('log', { message: '❌ Нет данных для импорта', level: 'error' });
            return;
        }

        try {
            const data = this.parseCSV(text);

            if (data.length === 0) {
                this.dispatchEvent('log', { message: '❌ Нет данных для импорта после парсинга', level: 'error' });
                return;
            }

            const dataWithFlag = data.map((item, index) => {
                const newItem = {
                    ...item,
                    isImported: true, // Добавляем флаг
                    timestamp: item.timestamp || Date.now() // Убеждаемся, что timestamp есть
                };
                return newItem;
            });

            this.dispatchEvent('importData', { data: dataWithFlag }); // ВАЖНО: ключ 'data'
            this.importTextarea.value = '';
            this.dispatchEvent('log', { message: `✅ Импортировано ${dataWithFlag.length} записей`, level: 'success' });
        } catch (err) {
            console.error("[SettingsSection] Ошибка импорта:", err);
            this.dispatchEvent('log', { message: `❌ Ошибка импорта: ${err.message}`, level: 'error' });
        }
    }

    async handleClearImported() {
        console.log("[SettingsSection] Начало handleClearImported");
        this.dispatchEvent('log', { message: '📤 Отправка команды на очистку импортированных данных...', level: 'info' });

        try {
            // Отправляем сообщение в background
            const response = await chrome.runtime.sendMessage({
                action: "clearImportedTableData"
            });

            if (response && response.status === "success") {
                console.log("[SettingsSection] Импортированные данные успешно очищены в background");
                this.dispatchEvent('log', { message: '✅ Импортированные данные очищены', level: 'success' });
                // Опционально: можно отправить событие, если другим компонентам нужно знать
                // this.dispatchEvent('importedDataCleared');
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка';
                console.error("[SettingsSection] Ошибка очистки в background:", errorMsg);
                this.dispatchEvent('log', { message: `❌ Ошибка очистки: ${errorMsg}`, level: 'error' });
            }
        } catch (err) {
            console.error("[SettingsSection] Ошибка отправки команды в background:", err);
            this.dispatchEvent('log', { message: `❌ Ошибка связи: ${err.message}`, level: 'error' });
        }
    }

    parseCSV(text) {
        const lines = text.split(/\r?\n/);
        if (lines.length === 0) {
            throw new Error('Пустой файл');
        }

        // Определяем разделитель: сначала пробуем ';', затем ','
        let delimiter = ';';
        if (lines[0].includes(',') && !lines[0].includes(';')) {
            delimiter = ',';
        }

        const headers = lines[0].split(delimiter).map(h => h.trim().toLowerCase());

        const required = ['название', 'id', 'просмотры', 'канал', 'исходное видео', 'миниатюра'];
        const fieldMap = {
            'название': 'title',
            'id': 'videoId',
            'просмотры': 'views',
            'канал': 'channelName',
            'исходное видео': 'sourceVideoId',
            'миниатюра': 'thumbnailUrl'
        };

        const indices = {};
        required.forEach(field => {
            const index = headers.findIndex(h => h === field);
            if (index === -1) {
                console.error("[SettingsSection] Не найдена колонка:", field);
                throw new Error(`Не найдена колонка: ${field}`);
            }
            indices[field] = index;
        });

        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) {
                continue;
            }
            const cells = line.split(delimiter).map(cell => {
                // Убираем окружающие кавычки, если они есть
                let trimmed = cell.trim();
                if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
                    trimmed = trimmed.substring(1, trimmed.length - 1);
                }
                return trimmed;
            });

            if (cells.length < headers.length) {
                console.warn(`[SettingsSection] Недостаточно ячеек в строке ${i}, пропускаем`);
                continue; // Пропускаем строки с недостаточным количеством ячеек
            }

            const item = {};
            required.forEach(field => {
                const index = indices[field];
                item[fieldMap[field]] = cells[index] ? cells[index] : '';
            });
            data.push(item);
        }
        return data;
    }

    dispatchEvent(type, detail) {
        document.dispatchEvent(new CustomEvent(type, { detail }));
    }
}

=== END FILE: D:\разработка\youtube-parser-os\popup\components\SettingsSection.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\components\TableSection.js ===

// popup/components/TableSection.js

export class TableSection {
    constructor() {
        this.tableBody = document.getElementById('tableBody');
        this.init();
    }

    init() {
        // Слушаем внутренние события
        document.addEventListener('updateTable', (e) => this.render(e.detail));
        document.addEventListener('clearTable', () => this.clear());
        // При инициализации сразу загружаем начальные данные
        this.loadInitialData();
    }

    /**
     * Загружает и отображает начальные данные из хранилища.
     * Запрашивает только "свежие" (не импортированные) данные.
     */
    async loadInitialData() {
        console.log("TableSection: Загрузка начальных данных (только свежие)...");
        try {
            // Отправляем сообщение в background для получения ТОЛЬКО свежих данных
            const response = await chrome.runtime.sendMessage({ action: "getTableFreshData" });
            const data = response?.data || [];
            console.log(`TableSection: Получено ${data.length} свежих записей.`);
            this.render(data);
        } catch (error) {
            console.error("TableSection: Ошибка при загрузке начальных данных:", error);
            this.clear();
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `⚠️ Ошибка загрузки таблицы: ${error.message}`, level: 'error' } }));
        }
    }

    /**
     * Рендерит данные в таблицу.
     * @param {Array<Object>} data - Массив объектов видео.
     */
    render(data = []) {
        this.tableBody.innerHTML = '';
        if (data.length === 0) {
            this.#showPlaceholder();
            return;
        }

        // Ограничиваем количество отображаемых строк для производительности
        const dataToShow = data.slice(-50); // последние 50

        dataToShow.forEach(video => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${this.#escapeHtml(video.title || '')}</td>
                <td>${this.#escapeHtml(video.videoId || '')}</td>
                <td>${this.#escapeHtml(video.views || '')}</td>
                <td>${this.#escapeHtml(video.channelName || '')}</td>
                <td>${this.#escapeHtml(video.sourceVideoId || '')}</td>
                <td>
                    ${video.thumbnailUrl ?
                    `<img src="${video.thumbnailUrl}" alt="Thumbnail" onerror="this.parentElement.innerHTML='—'">` :
                    '—'}
                </td>
            `;
            this.tableBody.appendChild(row);
        });
    }

    /**
     * Очищает таблицу и показывает placeholder.
     */
    clear() {
        this.tableBody.innerHTML = '';
        this.#showPlaceholder();
    }

    // --- Вспомогательные методы ---

    /**
     * Показывает placeholder "Таблица пуста".
     * @private
     */
    #showPlaceholder() {
        const placeholderRow = document.createElement('tr');
        placeholderRow.className = 'table-placeholder';
        placeholderRow.innerHTML = `<td colspan="6">Таблица пуста</td>`;
        this.tableBody.appendChild(placeholderRow);
    }

    /**
     * Экранирует HTML-сущности.
     * @param {string} text - Текст для экранирования.
     * @returns {string} - Экранированный текст.
     * @private
     */
    #escapeHtml(text) {
        if (typeof text !== 'string') return '';
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "<")
            .replace(/>/g, ">")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
}

=== END FILE: D:\разработка\youtube-parser-os\popup\components\TableSection.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\scenarios\parse-recommendation.js ===

// scenarios/parse-recommendation.js
import { scrollPageNTimes } from '../core/utils/scroller.js';
// import { logger } from '../background/background.js'; // Будет использоваться через context.log

/**
 * @type {import('../core/types/scenario.types.js').ScenarioDefinition}
 */
export const parseRecommendationScenario = {
    id: 'parse-recommendation',
    name: 'Парсинг рекомендаций',
    description: 'Прокручивает страницу с рекомендациями и готовит данные для парсинга.',

    /**
     * @param {import('../core/types/scenario.types.js').ScenarioContext} context
     */
    async execute(context) {
        const { log, params = {}, tabId, abortSignal } = context;

        // Параметры по умолчанию, как указано в задаче
        const scrollParams = {
            count: parseInt(params.count, 10) || 16,
            delayMs: parseInt(params.delayMs, 10) || 1500,
            step: parseInt(params.step, 10) || 1000
        };

        log(`🚀 Сценарий "Парсинг рекомендаций" запущен.`, { module: 'ParseRecommendation' });
        log(`🔧 Параметры скроллинга: ${JSON.stringify(scrollParams)}`, { module: 'ParseRecommendation' });

        try {
            // Проверяем, не было ли запроса на остановку до начала
            await abortSignal();

            // --- 1. Скроллинг страницы ---
            await scrollPageNTimes(context, scrollParams.count, scrollParams.delayMs, scrollParams.step);

            // --- 2. TODO: Парсинг и подсветка (в следующем шаге) ---
            // const parsedCards = await parseAndHighlight(context);
            // log(`✅ Найдено и подсвечено ${parsedCards.length} видео.`, { module: 'ParseRecommendation' });

            // --- 3. TODO: Скрапинг данных (в следующем шаге) ---
            // const scrapedData = await scrapeCards(context, parsedCards);
            // log(`💾 Скрапинг завершён. Получено данных по ${scrapedData.length} видео.`, { module: 'ParseRecommendation' });

            // --- 4. TODO: Сохранение данных (в следующем шаге) ---
            // await saveData(context, scrapedData);

            log(`🎉 Сценарий "Парсинг рекомендаций" успешно завершён.`, { module: 'ParseRecommendation' });

        } catch (error) {
            if (error.message === 'Сценарий остановлен пользователем.') {
                log(`⏹️ Сценарий "Парсинг рекомендаций" остановлен пользователем.`, { module: 'ParseRecommendation', level: 'warn' });
            } else {
                log(`❌ Ошибка в сценарии "Парсинг рекомендаций": ${error.message}`, { module: 'ParseRecommendation', level: 'error' });
                throw error; // Перебрасываем ошибку для обработки в ScenarioEngine
            }
        }
    }
};

=== END FILE: D:\разработка\youtube-parser-os\scenarios\parse-recommendation.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\scenarios\test-countdown.js ===

// scenarios/test-countdown.js
import { logger } from '../background/background.js';
import { tableAdapter } from '../background/background.js';

// --- Переносим вспомогательные функции внутрь модуля ---
/**
 * Генерирует случайную строку заданной длины.
 * @param {number} length
 * @returns {string}
 */
function generateRandomString(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}

/**
 * Генерирует случайное число просмотров.
 * @returns {string}
 */
function generateRandomViews() {
    const num = Math.floor(Math.random() * 1000000);
    if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
    if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
    return num.toString();
}
// --- Конец вспомогательных функций ---

/**
 * @type {import('../core/types/scenario.types.js').ScenarioDefinition}
 */
export const testCountdownScenario = {
    id: 'test-countdown',
    name: 'Тестовый сценарий: Обратный отсчет',
    description: 'Считает от 1 до N, где N - количество итераций из настроек. Логирует выбранный алгоритм.',

    /**
     * @param {import('../core/types/scenario.types.js').ScenarioContext} context
     */
    async execute(context) {
        // 1. Получаем параметры из контекста
        const { log, abortSignal, params = {} } = context;

        // 2. Извлекаем параметры или используем значения по умолчанию
        // ВАЖНО: ключи params должны совпадать с тем, что отправляется из popup/background
        const maxCount = parseInt(params.iterations, 10) || 10;
        // Интерпретируем внутренние значения mode в человекочитаемые названия для логов
        let selectionModeLabel = 'Неизвестный режим';
        if (params.mode === 'all_videos') {
            selectionModeLabel = 'Анализ всех видео';
        } else if (params.mode === 'current_recommendations') {
            selectionModeLabel = 'Анализ видео из последней подборки';
        }
        // Используем внутреннее значение mode для логики (если потребуется в будущем)
        const mode = params.mode || 'all_videos';
        const sourceVideoId = 'test_source_video_id'; // Для теста

        // 3. Логируем начальные параметры (используем человекочитаемое название)
        log(`🚀 Тестовый сценарий запущен.`, { module: 'TestScenario' });
        log(`🔢 Количество шагов: ${maxCount}`, { module: 'TestScenario' });
        log(`🧠 Алгоритм выбора: ${selectionModeLabel}`, { module: 'TestScenario' });
        // 4. Основной цикл
        for (let i = 1; i <= maxCount; i++) {
            // Проверяем, не был ли запрос на остановку
            await abortSignal();

            log(`⏱️ Шаг ${i}/${maxCount}`, { module: 'TestScenario' });

            // --- Запись случайных данных в таблицу ---
            try {
                const randomVideoData = {
                    videoId: `test_video_${generateRandomString(8)}`,
                    title: `Тестовое видео ${i}: ${generateRandomString(15)}`,
                    channelName: `Тестовый канал ${generateRandomString(5)}`,
                    views: generateRandomViews(),
                    sourceVideoId: sourceVideoId,
                    thumbnailUrl: `https://picsum.photos/seed/${i}/120/90`, // URL к случайной картинке
                    timestamp: Date.now()
                };

                await tableAdapter.add(randomVideoData);
                log(`💾 Данные шага ${i} записаны в таблицу.`, { module: 'TestScenario' });
            } catch (err) {
                log(`❌ Ошибка записи данных шага ${i}: ${err.message}`, { module: 'TestScenario', level: 'error' });
            }
            // --- Конец записи данных ---

            // Ждем 1 секунду
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        // 5. Логируем завершение и снова указываем параметры
        log(`🎉 Тестовый сценарий завершен.`, { module: 'TestScenario' });
        log(`🧠 Использованный алгоритм: ${selectionModeLabel}`, { module: 'TestScenario' });
        log(`🔢 Выполнено шагов: ${maxCount}`, { module: 'TestScenario' });
    }
};

=== END FILE: D:\разработка\youtube-parser-os\scenarios\test-countdown.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\shared\logger.js ===



=== END FILE: D:\разработка\youtube-parser-os\shared\logger.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\shared\storage.js ===



=== END FILE: D:\разработка\youtube-parser-os\shared\storage.js ===

--------------------------------------------------------------------------------
