
=== START FILE: D:\разработка\youtube-parser-os\manifest.json ===

{
    "manifest_version": 3,
    "name": "YouTube Рекомендации Парсер OS",
    "version": "1.0.0",
    "description": "Новый архитектурный фундамент для парсинга YouTube.",
    "icons": {
        "16": "icons/icon16.png"
    },
    "action": {
        "default_popup": "popup/popup.html",
        "default_icon": {
            "16": "icons/icon16.png"
        }
    },
    "background": {
        "service_worker": "background/background.js",
        "type": "module"
    },
    "content_scripts": [
        {
            "matches": [
                "*://*.youtube.com/*"
            ],
            "js": [
                "content/modules/scroller.js",
                "content/modules/parser.js",
                "content/modules/scraper.js",
                "content/modules/video-checker.js",
                "content/content.js"
            ],
            "run_at": "document_idle"
        }
    ],
    "permissions": [
        "activeTab",
        "scripting",
        "storage",
        "tabs"
    ],
    "host_permissions": [
        "*://*.youtube.com/*"
    ]
}

=== END FILE: D:\разработка\youtube-parser-os\manifest.json ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\adapters\ChromeStorageLogAdapter.js ===

// adapters/ChromeStorageLogAdapter.js
import { Logger } from '../core/logger.js'; // Для типов

/**
 * @typedef {import('../core/types/log.types.js').LogEntry} LogEntry
 * @typedef {import('../core/types/log.types.js').LogAdapter} LogAdapter
 */

export class ChromeStorageLogAdapter {
    /** @type {string} */
    #storageKey;
    /** @type {number} */
    #maxSize;

    /**
     * @param {Object} options
     * @param {string} [options.storageKey='appLogs']
     * @param {number} [options.maxSize=500]
     */
    constructor(options = {}) {
        // Проверяем доступность chrome.storage.local
        if (typeof chrome === 'undefined' || !chrome.storage || !chrome.storage.local) {
            throw new Error('ChromeStorageLogAdapter: chrome.storage.local is not available.');
        }

        this.#storageKey = options.storageKey ?? 'appLogs';
        this.#maxSize = options.maxSize ?? 500;
    }

    /**
     * @param {LogEntry} entry
     * @returns {Promise<void>}
     */
    async write(entry) {
        try {
            const logs = await this.read();
            logs.push(entry);
            if (logs.length > this.#maxSize) {
                logs.splice(0, logs.length - this.#maxSize);
            }
            await chrome.storage.local.set({ [this.#storageKey]: logs });
        } catch (e) {
            console.error("[ChromeStorageLogAdapter] Ошибка записи:", e);
            // В реальном адаптере можно выбрасывать ошибку или логировать иначе
            // throw e;
        }
    }

    /**
     * @returns {Promise<LogEntry[]>}
     */
    async read() {
        try {
            const result = await chrome.storage.local.get([this.#storageKey]);
            return result[this.#storageKey] || [];
        } catch (e) {
            console.error("[ChromeStorageLogAdapter] Ошибка чтения:", e);
            return [];
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async clear() {
        try {
            await chrome.storage.local.remove([this.#storageKey]);
        } catch (e) {
            console.error("[ChromeStorageLogAdapter] Ошибка очистки:", e);
        }
    }
}

=== END FILE: D:\разработка\youtube-parser-os\adapters\ChromeStorageLogAdapter.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\adapters\ChromeStorageTableAdapter.js ===

// adapters/ChromeStorageTableAdapter.js

/**
 * @typedef {import('../core/types/table.types.js').VideoData} VideoData
 * @typedef {import('../core/types/table.types.js').TableAdapter} TableAdapter
 */

export class ChromeStorageTableAdapter {
    /** @type {string} */
    #storageKey;
    /** @type {number} */
    #maxSize;

    /**
     * @param {Object} options
     * @param {string} [options.storageKey='parsedVideos']
     * @param {number} [options.maxSize=100000]
     */
    constructor(options = {}) {
        if (typeof chrome === 'undefined' || !chrome.storage || !chrome.storage.local) {
            throw new Error('ChromeStorageTableAdapter: chrome.storage.local is not available.');
        }

        this.#storageKey = options.storageKey ?? 'parsedVideos';
        this.#maxSize = options.maxSize ?? 100000; // Увеличенный размер для больших данных
    }

    /**
     * @param {VideoData} videoData
     * @returns {Promise<void>}
     */
    async add(videoData) {
        try {
            const allData = await this.getAll();
            allData.push(videoData);

            // Ограничиваем размер, удаляя старые записи с начала
            if (allData.length > this.#maxSize) {
                allData.splice(0, allData.length - this.#maxSize);
            }

            await chrome.storage.local.set({ [this.#storageKey]: allData });

            // Отправляем сообщение всем popup'ам об обновлении данных
            this.#broadcastDataUpdate();
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка добавления записи:", e);
            throw e;
        }
    }

    /**
     * @param {VideoData[]} videoDataArray
     * @returns {Promise<void>}
     */
    async addBatch(videoDataArray) {
        if (!Array.isArray(videoDataArray) || videoDataArray.length === 0) {
            return;
        }

        try {
            const allData = await this.getAll();
            allData.push(...videoDataArray);

            // Ограничиваем размер
            if (allData.length > this.#maxSize) {
                allData.splice(0, allData.length - this.#maxSize);
            }

            await chrome.storage.local.set({ [this.#storageKey]: allData });

            // Отправляем сообщение об обновлении данных
            this.#broadcastDataUpdate();
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка добавления записей:", e);
            throw e;
        }
    }

    /**
     * @returns {Promise<VideoData[]>}
     */
    async getAll() {
        try {
            const result = await chrome.storage.local.get([this.#storageKey]);
            return result[this.#storageKey] || [];
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка получения записей:", e);
            return [];
        }
    }

    /**
     * @returns {Promise<void>}
     */
    async clear() {
        try {
            await chrome.storage.local.remove([this.#storageKey]);
            // Отправляем сообщение об очистке данных
            this.#broadcastDataCleared();
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка очистки:", e);
            throw e;
        }
    }

    /**
     * @returns {Promise<number>}
     */
    async getCount() {
        try {
            const data = await this.getAll();
            return data.length;
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка получения количества записей:", e);
            return 0;
        }
    }

    /**
     * Получает все записи, которые НЕ являются импортированными.
     * Используется для отображения в UI.
     * @returns {Promise<import('../core/types/table.types.js').VideoData[]>}
     */
    async getFreshData() {
        try {
            const allData = await this.getAll();
            // Фильтруем, оставляя только "свежие" записи
            return allData.filter(item => !item.isImported);
        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка получения свежих данных:", e);
            return [];
        }
    }

    /**
     * Очищает только записи, помеченные как импортированные (isImported: true).
     * @returns {Promise<void>}
     */
    async clearImported() {
        try {
            console.log("[ChromeStorageTableAdapter] Начало очистки импортированных данных...");
            // 1. Получаем все данные
            const allData = await this.getAll();
            console.log(`[ChromeStorageTableAdapter] Всего записей до очистки: ${allData.length}`);

            // 2. Фильтруем, оставляя только НЕ импортированные данные
            const freshData = allData.filter(item => !item.isImported);
            console.log(`[ChromeStorageTableAdapter] Останется записей после очистки: ${freshData.length}`);

            // 3. Сохраняем обратно только "свежие" данные
            // Используем максимальный размер для сохранения
            if (freshData.length > this.#maxSize) {
                freshData.splice(0, freshData.length - this.#maxSize);
            }

            await chrome.storage.local.set({ [this.#storageKey]: freshData });
            console.log("[ChromeStorageTableAdapter] Импортированные данные успешно удалены из хранилища.");

            // 4. Отправляем сообщение об обновлении данных, так как состав изменился
            // Это заставит popup перезагрузить "свежие" данные
            this.#broadcastDataUpdate();

        } catch (e) {
            console.error("[ChromeStorageTableAdapter] Ошибка очистки импортированных данных:", e);
            throw e;
        }
    }

    /**
     * Отправляет сообщение о том, что данные обновились.
     * @private
     */
    #broadcastDataUpdate() {
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            chrome.runtime.sendMessage({ type: "dataUpdated" }).catch(err => {
                // Игнорируем ошибки, если popup закрыт
                if (!chrome.runtime.lastError) {
                    console.debug("Ошибка при отправке dataUpdated:", err);
                }
            });
        }
    }

    /**
     * Отправляет сообщение о том, что данные очищены.
     * @private
     */
    #broadcastDataCleared() {
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            chrome.runtime.sendMessage({ type: "dataCleared" }).catch(err => {
                if (!chrome.runtime.lastError) {
                    console.debug("Ошибка при отправке dataCleared:", err);
                }
            });
        }
    }
}

=== END FILE: D:\разработка\youtube-parser-os\adapters\ChromeStorageTableAdapter.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\adapters\ConsoleLogAdapter.js ===

// adapters/ConsoleLogAdapter.js

/**
 * @typedef {import('../core/types/log.types.js').LogEntry} LogEntry
 * @typedef {import('../core/types/log.types.js').LogAdapter} LogAdapter
 */

export class ConsoleLogAdapter {
    /**
     * @param {LogEntry} entry
     * @returns {Promise<void>}
     */
    async write(entry) {
        // Логика уже есть в основном классе, но можно и здесь реализовать
        // например, если нужен специфичный формат только для консоли
        // Пока оставим пустым, так как дублирование происходит в Logger
    }

    /**
     * @returns {Promise<LogEntry[]>}
     */
    async read() {
        console.warn("[ConsoleLogAdapter] Чтение логов из консоли невозможно");
        return [];
    }

    /**
     * @returns {Promise<void>}
     */
    async clear() {
        console.clear(); // Физически очищает консоль браузера
    }
}

=== END FILE: D:\разработка\youtube-parser-os\adapters\ConsoleLogAdapter.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\background\background.js ===

// background/background.js
// Импортируем новые модули
import { Logger } from '../core/logger.js';
import { ChromeStorageLogAdapter } from '../adapters/ChromeStorageLogAdapter.js';
import { ChromeStorageTableAdapter } from '../adapters/ChromeStorageTableAdapter.js';
import { ScenarioEngine } from '../core/scenario-engine.js';
import { testCountdownScenario } from '../scenarios/test-countdown.js';
import { prepareImportedDataIndices } from '../core/data-processor.js';
import { parseRecommendationScenario } from '../scenarios/parse-recommendation.js';
import {
    initialize as initIndexManager,
    reset as resetIndexManager,
    getStateSnapshot,
    addScrapedData as updateIndexManagerWithData
} from '../core/index-manager.js';

// --- Инициализация нового функционала ---
// 1. Создаем экземпляр логгера
export const logger = new Logger({
    maxSize: 1000,
    enableConsole: true,
    defaultLevel: 'info'
});

export const tableAdapter = new ChromeStorageTableAdapter({
    maxSize: 100000 // Установим большой лимит
});

export async function getImportedDataIndices() {
    try {
        const allData = await tableAdapter.getAll();
        // Фильтруем только импортированные данные
        const importedData = allData.filter(item => item.isImported === true);
        logger.debug(`[Background] Получено ${importedData.length} импортированных записей для индексации.`, { module: 'Background' });
        return prepareImportedDataIndices(importedData);
    } catch (error) {
        logger.error(`[Background] Ошибка при получении/индексации импортированных данных: ${error.message}`, { module: 'Background' });
        // Возвращаем пустые структуры в случае ошибки
        return {
            visitedVideoIds: new Set(),
            channelVideoCounts: new Map(),
            channelToVideoIds: new Map()
        };
    }
}
// logger по умолчанию уже добавил ChromeStorageLogAdapter, но мы можем добавить ещё

// 2. Создаем экземпляр движка сценариев
export const scenarioEngine = new ScenarioEngine();

// 3. Регистрируем тестовый сценарий
scenarioEngine.registerScenario(testCountdownScenario);
scenarioEngine.registerScenario(parseRecommendationScenario);

// --- Инициализация IndexManager ---
// Вызывается один раз при запуске background script
async function initializeBackgroundState() {
    logger.info("🚀 Background service worker запущен и готов к работе.", { module: 'Background' });

    try {
        // 1. Инициализируем IndexManager данными из tableAdapter
        logger.info("🔄 Инициализация IndexManager...", { module: 'Background' });
        const allStoredData = await tableAdapter.getAll();
        await initIndexManager(allStoredData);
        logger.info(`✅ IndexManager инициализирован. Загружено ${allStoredData.length} записей.`, { module: 'Background' });

        // 2. Можно инициализировать другие части системы...

    } catch (initErr) {
        logger.error(`❌ Ошибка инициализации background: ${initErr.message}`, { module: 'Background' });
        // Важно: не останавливаем весь background из-за ошибки инициализации
        // но логируем критично
    }
}

// Вызываем инициализацию
initializeBackgroundState().catch(err => {
    console.error("[Background] Критическая ошибка при инициализации:", err);
    // logger может быть еще не инициализирован, поэтому console.error тоже важен
});
// --- Конец инициализации нового функционала ---

// --- Обработка сообщений от popup ---
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {

    if (request.type === "contentLog") {
        console.log("[Background] Получен лог от content script:", request);
        // Перенаправляем лог в наш logger
        logger.log(
            request.message,
            request.level || 'info',
            {
                module: request.module || 'ContentScript',
                // Можно добавить ID вкладки, если нужно
                // tabId: sender.tab?.id
            }
        );
        // Намеренно не отправляем sendResponse, так как это одностороннее сообщение
        return false; // Не нужно ждать асинхронного ответа
    }

    if (request.action === "stopAllScenarios") {
        logger.info("📥 Получена команда на остановку всех сценариев", { module: 'Background' });
        (async () => {
            try {
                // Получаем список всех запущенных сценариев
                const runningScenarios = scenarioEngine.getRunningScenarios();
                if (runningScenarios.length === 0) {
                    logger.info("📭 Нет запущенных сценариев для остановки", { module: 'Background' });
                    sendResponse({ status: "success", message: "Нет запущенных сценариев" });
                    return;
                }

                logger.info(`⏹️ Запрошена остановка ${runningScenarios.length} сценариев`, { module: 'Background' });

                let stoppedCount = 0;
                let errorCount = 0;

                const stopPromises = runningScenarios.map(async (scenario) => {
                    try {
                        // ScenarioEngine.stop возвращает true, если сценарий был найден и остановлен
                        const wasStopped = scenarioEngine.stop(scenario.id);
                        if (wasStopped) {
                            stoppedCount++;
                            logger.info(`⏹️ Сценарий "${scenario.name}" (ID: ${scenario.id}) остановлен`, { module: 'Background' });
                        } else {
                            // Это маловероятно, так как мы только что получили список запущенных
                            logger.warn(`⚠️ Сценарий "${scenario.name}" (ID: ${scenario.id}) не был остановлен (уже завершен?)`, { module: 'Background' });
                        }
                    } catch (err) {
                        errorCount++;
                        logger.error(`❌ Ошибка при остановке сценария "${scenario.name}" (ID: ${scenario.id}): ${err.message}`, { module: 'Background' });
                    }
                });

                // Ждем завершения всех попыток остановки
                await Promise.allSettled(stopPromises);

                const resultMessage = `Остановлено сценариев: ${stoppedCount}. Ошибок: ${errorCount}.`;
                logger.info(`🏁 Результат остановки: ${resultMessage}`, { module: 'Background' });

                sendResponse({ status: "success", message: resultMessage });

            } catch (err) {
                logger.error(`❌ Ошибка при остановке сценариев: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    if (request.action === "getScenarioStatus") {
        logger.debug("📥 Получен запрос состояния сценариев", { module: 'Background' });
        try {
            const runningScenarios = scenarioEngine.getRunningScenarios();
            const isRunning = runningScenarios.length > 0;
            // Можно также отправить список запущенных сценариев, если нужно
            sendResponse({ status: "success", isRunning: isRunning, runningScenarios: runningScenarios });
            logger.debug(`📤 Отправлено состояние сценариев: isRunning=${isRunning}`, { module: 'Background' });
        } catch (err) {
            logger.error(`❌ Ошибка при получении состояния сценариев: ${err.message}`, { module: 'Background' });
            sendResponse({ status: "error", message: err.message });
        }
        return true; // keep channel open for async response (на случай, если getRunningScenarios станет асинхронным в будущем)
    }

    if (request.action === "runScenario") {
        const { scenarioId, params = {} } = request;
        logger.info(`📥 Получена команда на запуск сценария "${scenarioId}"`, { module: 'Background', meta: params });

        (async () => {
            try {
                let activeTabId = null;
                logger.debug("Попытка получить активную вкладку...", { module: 'Background' });

                try {
                    // Попытка 1: Получить активную вкладку в текущем окне
                    const activeTabsCurrentWindow = await chrome.tabs.query({ active: true, currentWindow: true });
                    logger.debug(`Результат query({active: true, currentWindow: true}):`, activeTabsCurrentWindow, { module: 'Background' });
                    if (activeTabsCurrentWindow.length > 0) {
                        activeTabId = activeTabsCurrentWindow[0].id;
                        logger.debug(`Найдена активная вкладка в текущем окне: ID=${activeTabId}`, { module: 'Background' });
                    } else {
                        logger.warn("Активная вкладка в текущем окне не найдена.", { module: 'Background' });
                    }
                } catch (queryErr1) {
                    logger.warn(`Ошибка при попытке 1 получения активной вкладки: ${queryErr1.message}`, { module: 'Background' });
                }

                // Если не нашли, попробуем более общий запрос
                if (activeTabId === null) {
                    logger.debug("Попытка 2: Получить любую активную вкладку...", { module: 'Background' });
                    try {
                        const activeTabsAnyWindow = await chrome.tabs.query({ active: true });
                        logger.debug(`Результат query({active: true}):`, activeTabsAnyWindow, { module: 'Background' });
                        if (activeTabsAnyWindow.length > 0) {
                            // Берем первую, обычно это та, что в текущем окне
                            activeTabId = activeTabsAnyWindow[0].id;
                            logger.debug(`Найдена активная вкладка (любая): ID=${activeTabId}`, { module: 'Background' });
                        } else {
                            logger.warn("Не найдено ни одной активной вкладки.", { module: 'Background' });
                        }
                    } catch (queryErr2) {
                        logger.warn(`Ошибка при попытке 2 получения активной вкладки: ${queryErr2.message}`, { module: 'Background' });
                    }
                }

                // Если все еще null, логируем предупреждение, но продолжаем (сценарий может сам решить, что делать)
                if (activeTabId === null) {
                    logger.warn("❌ Не удалось получить активную вкладку. tabId будет null. Сценарий может не работать с контентом страницы.", { module: 'Background' });
                    // Не бросаем ошибку здесь, пусть сценарий сам решает, критично ли это.
                    // Но для скроллинга это критично, поэтому сценарий должен это обработать.
                } else {
                    logger.info(`✅ Активная вкладка определена: ID=${activeTabId}`, { module: 'Background' });
                }

                // Определяем, какой сценарий запускать
                let scenarioToRun;
                if (scenarioId === 'parse-recommendation') {
                    scenarioToRun = parseRecommendationScenario;
                } else if (scenarioId === 'test-countdown') {
                    scenarioToRun = testCountdownScenario;
                    // } else if (scenarioId === '...') {
                    //     scenarioToRun = ...;
                } else {
                    throw new Error(`Неизвестный ID сценария: ${scenarioId}`);
                }

                // Передаем параметры и tabId в сценарий через context.params и context.tabId
                const instanceId = await scenarioEngine.run(scenarioToRun, params, activeTabId);
                logger.info(`🏁 Сценарий "${scenarioId}" запущен с ID: ${instanceId}`, { module: 'Background' });

                sendResponse({ status: "started", instanceId: instanceId });

            } catch (err) {
                logger.error(`❌ Ошибка запуска сценария "${scenarioId}": ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();

        return true; // keep channel open for async response
    }

    if (request.action === "clearImportedTableData") {
        (async () => {
            try {
                logger.info("📥 Получена команда на очистку импортированных данных", { module: 'Background' });

                // Вызываем метод адаптера
                await tableAdapter.clearImported();

                logger.info("✅ Импортированные данные очищены", { module: 'Background' });
                sendResponse({ status: "success" });

            } catch (err) {
                logger.error(`❌ Ошибка очистки импортированных данных: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    if (request.action === "getTableFreshData") {
        (async () => {
            try {
                // Используем новый метод адаптера
                const data = await tableAdapter.getFreshData();
                sendResponse({ status: "success", data });
            } catch (err) {
                logger.error(`❌ Ошибка получения свежих данных таблицы: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // Указывает, что ответ будет асинхронным
    }

    if (request.action === "DEBUG_getImportedDataIndices") {
        (async () => {
            try {
                console.log("[DEBUG] Получение индексов импортированных данных по запросу из popup/console...");
                const indices = await getImportedDataIndices(); // Эта функция доступна внутри модуля

                // Maps и Sets нужно сериализовать для отправки
                const serializableData = {
                    visitedVideoIds_size: indices.visitedVideoIds.size,
                    channelVideoCounts_size: indices.channelVideoCounts.size,
                    channelToVideoIds_size: indices.channelToVideoIds.size,

                    // Добавим примеры для лучшей проверки
                    visitedVideoIds_sample: Array.from(indices.visitedVideoIds).slice(0, 5),
                    channelVideoCounts_sample: Object.fromEntries(
                        Array.from(indices.channelVideoCounts).slice(0, 5)
                    ),
                    channelToVideoIds_sample: Object.fromEntries(
                        Array.from(indices.channelToVideoIds, ([k, v]) => [k, Array.from(v).slice(0, 3)]).slice(0, 3)
                    )
                };

                console.log("[DEBUG] Индексы получены:", serializableData);
                sendResponse({ status: "success", data: serializableData });
            } catch (err) {
                console.error("[DEBUG] Ошибка в getImportedDataIndices:", err);
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    if (request.action === "importTableData") {
        (async () => {
            try {
                if (!request.data || !Array.isArray(request.data)) {
                    const errorMsg = "Некорректные данные для импорта";
                    logger.warn(`[Background] ${errorMsg}`, { module: 'Background' });
                    sendResponse({ status: "error", message: errorMsg });
                    return;
                }

                const dataToImport = request.data;
                logger.info(`📥 Начинаем импорт ${dataToImport.length} записей...`, { module: 'Background' });

                // 1. Добавляем данные в tableAdapter (основное хранилище)
                // Предполагается, что tableAdapter.addBatch существует и работает
                if (typeof tableAdapter.addBatch === 'function') {
                    await tableAdapter.addBatch(dataToImport);
                } else if (typeof tableAdapter.add === 'function') {
                    // Если addBatch нет, добавляем по одной (менее эффективно)
                    logger.warn("[Background] tableAdapter.addBatch не найден, используем add для каждой записи...", { module: 'Background' });
                    for (const item of dataToImport) {
                        await tableAdapter.add(item);
                    }
                } else {
                    throw new Error("Адаптер таблицы не поддерживает методы добавления (add/addBatch)");
                }

                logger.info(`✅ Импортировано ${dataToImport.length} записей в tableAdapter`, { module: 'Background' });

                // 👇 НОВОЕ: Обновляем IndexManager импортированными данными
                try {
                    logger.info(`🔄 Обновление IndexManager ${dataToImport.length} импортированными записями...`, { module: 'Background' });
                    updateIndexManagerWithData(dataToImport); // Вызываем функцию из IndexManager
                    logger.info(`✅ IndexManager успешно обновлен импортированными данными.`, { module: 'Background' });
                } catch (indexUpdateErr) {
                    // Логируем ошибку, но не прерываем основной процесс импорта
                    logger.error(`⚠️ Ошибка обновления IndexManager после импорта: ${indexUpdateErr.message}`, { module: 'Background' });
                }

                sendResponse({ status: "success", count: dataToImport.length });

                // 👇 НОВОЕ: Оповещаем popup о том, что данные обновились (если нужно)
                // Это может быть полезно, если popup хочет обновить таблицу или индексы
                // chrome.runtime.sendMessage({ type: "dataUpdated" }).catch(err => { /* ignore */ });

            } catch (err) {
                logger.error(`❌ Ошибка импорта данных: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    if (request.action === "getImportedDataIndices") {
        (async () => {
            try {
                const indices = await getImportedDataIndices();
                // Maps и Sets нельзя напрямую сериализовать в JSON, поэтому преобразуем
                const serializableIndices = {
                    visitedVideoIds: Array.from(indices.visitedVideoIds),
                    channelVideoCounts: Object.fromEntries(indices.channelVideoCounts),
                    channelToVideoIds: {} // Преобразуем Map<channel, Set<id>> в объект
                };
                for (const [channel, idSet] of indices.channelToVideoIds) {
                    serializableIndices.channelToVideoIds[channel] = Array.from(idSet);
                }
                sendResponse({ status: "success", data: serializableIndices });
            } catch (err) {
                logger.error(`[Background] Ошибка получения индексов: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // Для асинхронной отправки ответа
    }

    if (request.action === "getTableData") {
        (async () => {
            try {
                const data = await tableAdapter.getAll();
                sendResponse({ status: "success", data });
            } catch (err) {
                logger.error(`❌ Ошибка получения данных таблицы: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // Указывает, что ответ будет асинхронным
    }

    // 👇 НОВОЕ: обработка запроса на очистку таблицы
    if (request.action === "clearTableData") {
        (async () => {
            try {
                await tableAdapter.clear();
                sendResponse({ status: "success" });
                logger.info("✅ Таблица очищена", { module: 'Background' });
            } catch (err) {
                logger.error(`❌ Ошибка очистки таблицы: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true;
    }

    // 👇 НОВОЕ: обработка запроса на копирование таблицы (получение данных в формате TSV)
    if (request.action === "copyTableData") {
        (async () => {
            try {
                const data = await tableAdapter.getAll();
                // Фильтруем импортированные данные, если нужно
                const freshData = data.filter(v => !v.isImported);

                const headers = ['Название', 'ID', 'Просмотры', 'Канал', 'Исходное видео', 'Миниатюра'];
                const rows = freshData.map(v => [
                    v.title || '', v.videoId || '', v.views || '', v.channelName || '', v.sourceVideoId || '', v.thumbnailUrl || ''
                ]);

                const tsvContent = [headers.join('\t'), ...rows.map(r => r.join('\t'))].join('\n');
                sendResponse({ status: "success", data: tsvContent });
                logger.info(`📋 Таблица подготовлена для копирования (${freshData.length} строк)`, { module: 'Background' });
            } catch (err) {
                logger.error(`❌ Ошибка подготовки таблицы для копирования: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true;
    }

    // 👇 НОВОЕ: Обработчик для сброса индексов
    if (request.action === "resetIndices") {
        (async () => {
            try {
                logger.info("📥 Получена команда на сброс индексов.", { module: 'Background' });
                resetIndexManager();
                logger.info("✅ Индексы успешно сброшены.", { module: 'Background' });
                sendResponse({ status: "success", message: "Индексы сброшены." });
            } catch (err) {
                logger.error(`❌ Ошибка сброса индексов: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    // 👇 НОВОЕ: Обработчик для получения состояния индексов (для отладки/статистики в popup)
    if (request.action === "getIndexState") {
        (async () => {
            try {
                // logger.info("📥 Получен запрос состояния индексов.", { module: 'Background' });
                // getStateSnapshot возвращает копии, безопасно для сериализации
                const indexStateSnapshot = getStateSnapshot();

                // Maps и Sets нужно преобразовать для отправки через sendMessage
                // ВАЖНО: Создаем объект с полями, которые ожидает popup
                const serializableState = {
                    // Поля для scrapedDataBuffer
                    scrapedDataBuffer_count: indexStateSnapshot.scrapedDataBuffer.length,
                    // 👇 НОВОЕ: Отправляем сами данные буфера (или часть)
                    scrapedDataBuffer_sample: indexStateSnapshot.scrapedDataBuffer, // Отправляем первые 5 элементов

                    // Поля для visitedVideoIds
                    visitedVideoIds_count: indexStateSnapshot.visitedVideoIds.size,
                    // 👇 НОВОЕ: Отправляем сами ID (или часть)
                    visitedVideoIds_sample: Array.from(indexStateSnapshot.visitedVideoIds), // Отправляем первые 10 ID

                    // Поля для channelVideoCounts
                    channelVideoCounts_count: indexStateSnapshot.channelVideoCounts.size,
                    // 👇 НОВОЕ: Отправляем часть словаря
                    channelVideoCounts_sample: Object.fromEntries(
                        Array.from(indexStateSnapshot.channelVideoCounts) // Первые 10 каналов
                    ),

                    // Поля для channelToVideoIds
                    channelToVideoIds_count: indexStateSnapshot.channelToVideoIds.size,
                    // 👇 НОВОЕ: Отправляем часть словаря, преобразуя Set в Array
                    channelToVideoIds_sample: Object.fromEntries(
                        Array.from(indexStateSnapshot.channelToVideoIds, ([k, v]) => [k, Array.from(v)])
                    ),
                };

                sendResponse({ status: "success", serializableState });
            } catch (err) {
                logger.error(`❌ Ошибка получения состояния индексов: ${err.message}`, { module: 'Background' });
                sendResponse({ status: "error", message: err.message });
            }
        })();
        return true; // keep channel open for async response
    }

    // TODO: Здесь будут обработчики для других действий (parseOnce, startAutoAnalysis и т.д.)
    // которые мы постепенно перенесем на новую архитектуру.
    // Пока оставим заглушку или старую логику, если нужно проверить MVP.
});

logger.info("🚀 Background service worker запущен и готов к работе.", { module: 'Background' });

=== END FILE: D:\разработка\youtube-parser-os\background\background.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\content\content.js ===

// content/content.js
// window.performScrollNTimes доступна, так как scroller.js был подключен раньше

console.log("[Content Script] Загружен и готов к работе.");

// Слушаем сообщения от background.js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    console.log("[Content Script] Получено сообщение:", request);

    if (request.action === "performSingleScroll") {
        console.log("[Content Script] Начинаем выполнение ОДНОГО скролла:", request);

        // Выполняем скролл, вызывая функцию из глобальной области
        window.performSingleScroll(request.step)
            .then(() => {
                console.log("[Content Script] Один скролл выполнен успешно.");
                sendResponse({ status: "success" });
            })
            .catch((err) => {
                console.error("[Content Script] Ошибка выполнения одного скролла:", err);
                sendResponse({ status: "error", message: err.message });
            });

        // Возвращаем true, чтобы указать, что ответ будет асинхронным
        return true;
    }

    // --- Обработчики для парсинга и скрапинга ---
    if (request.action === "parseAndHighlight") {
        console.log("[Content Script] === Получен запрос на парсинг, подсветку и скрапинг ===");
        const { sourceVideoId = 'unknown' } = request; // Ожидаем sourceVideoId от background
        console.log("[Content Script] Используем sourceVideoId:", sourceVideoId);

        try {
            // 1. Найти и подсветить карточки
            const parsedCardElements = window.ytParser.parseAndHighlight(); // Это HTMLElement[]
            const count = parsedCardElements.length;
            console.log(`[Content Script] Найдено и подсвечено карточек: ${count}`);

            // 2. Извлечь данные из подсвеченных карточек
            // Передаем массив элементов и sourceVideoId в scraper
            const scrapedData = window.ytScraper.scrapeCards(parsedCardElements, sourceVideoId);
            console.log(`[Content Script] Извлечено данных из ${scrapedData.length} карточек.`);

            // 3. Вернуть данные
            sendResponse({
                status: "success",
                highlightedCount: count,
                scrapedData: scrapedData // Возвращаем сразу извлеченные данные
            });
            console.log("[Content Script] === Данные успешно отправлены ===");

        } catch (err) {
            console.error("[Content Script] Ошибка парсинга/скрапинга:", err);
            sendResponse({
                status: "error",
                message: err.message,
                // Даже при ошибке можем вернуть то, что успели найти
                highlightedCount: 0,
                scrapedData: []
            });
        }
        return true; // keep channel open for async response
    }

    // --- Обработчики для управления подсветкой ---
    if (request.action === "removeParserHighlights") {
        console.log("[Content Script] Получен запрос на удаление подсветки.");
        try {
            window.ytParser.removeHighlights();
            sendResponse({ status: "success" });
        } catch (err) {
            console.error("[Content Script] Ошибка удаления подсветки:", err);
            sendResponse({ status: "error", message: err.message });
        }
        return true;
    }

    if (request.action === "requestCardDetails") {
        console.log(`[Content Script] Получен запрос на данные по ${request.count} карточкам.`);
        try {
            // 1. Найти все подсвеченные карточки
            const highlightedCards = document.querySelectorAll('.video-highlighted');
            console.log(`[Content Script] Найдено подсвеченных карточек: ${highlightedCards.length}`);

            // 2. Извлечь данные из каждой
            const cardDetails = [];
            highlightedCards.forEach((cardElement, index) => {
                try {
                    // --- Логика извлечения данных, аналогичная core/scraper.js ---
                    // 1. Название видео
                    const titleElement = cardElement.querySelector('.yt-lockup-metadata-view-model__title');
                    const title = titleElement?.textContent?.trim() || 'Без названия';

                    // 2. ID видео из ссылки
                    const linkElement = cardElement.querySelector('a[href*="/watch?v="]');
                    let videoId = 'Не найден';
                    if (linkElement) {
                        try {
                            const url = new URL(linkElement.href);
                            videoId = url.searchParams.get('v') || 'Не удалось извлечь ID';
                        } catch (urlErr) {
                            console.warn(`[Content Script] Ошибка разбора URL для карточки ${index}:`, urlErr);
                        }
                    }

                    // 3. Количество просмотров
                    const viewsElement = cardElement.querySelector('.yt-lockup-metadata-view-model__byline-item');
                    const views = viewsElement?.textContent?.trim() || 'N/A';

                    // 4. Название канала
                    const channelElement = cardElement.querySelector('.yt-lockup-metadata-view-model__secondary-title');
                    const channelName = channelElement?.textContent?.trim() || 'N/A';

                    // 5. URL миниатюры (если нужно)
                    const thumbImg = cardElement.querySelector('img');
                    const thumbnailUrl = thumbImg?.src || 'N/A';

                    cardDetails.push({
                        videoId,
                        title,
                        views,
                        channelName,
                        thumbnailUrl
                        // Можно добавить больше полей при необходимости
                    });
                    console.log(`[Content Script] Данные извлечены для карточки ${index + 1}: ${title.substring(0, 30)}...`);
                } catch (scrapeErr) {
                    console.error(`[Content Script] Ошибка извлечения данных для карточки ${index}:`, scrapeErr);
                    // Добавляем карточку с ошибкой, чтобы сохранить порядок
                    cardDetails.push({
                        videoId: 'Ошибка извлечения',
                        title: `Ошибка: ${scrapeErr.message.substring(0, 50)}`,
                        views: 'N/A',
                        channelName: 'N/A',
                        thumbnailUrl: 'N/A'
                    });
                }
            });

            console.log(`[Content Script] Собрано данных по ${cardDetails.length} карточкам.`);
            sendResponse({
                status: "success",
                cardDetails: cardDetails
            });
        } catch (err) {
            console.error("[Content Script] Ошибка при сборе данных о карточках:", err);
            sendResponse({ status: "error", message: err.message });
        }
        return true; // keep channel open for async response
    }

    if (request.action === "checkVideoAvailability") {
        console.log("[Content Script] Получен запрос на проверку доступности видео.");
        (async () => {
            try {
                // Вызываем функцию из модуля video-checker
                const isAvailable = window.ytVideoChecker.isCurrentVideoAvailable();
                console.log(`[Content Script] Видео ${isAvailable ? 'доступно' : 'недоступно'}.`);
                sendResponse({ status: "success", isAvailable: isAvailable });
            } catch (err) {
                console.error("[Content Script] Ошибка проверки доступности видео:", err);
                sendResponse({ status: "error", message: err.message, isAvailable: true }); // В случае ошибки считаем доступным
            }
        })();
        return true; // keep channel open for async response
    }


    console.log("[Content Script] Неизвестное сообщение, игнорируем.");
});

=== END FILE: D:\разработка\youtube-parser-os\content\content.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\content\modules\parser.js ===

// content/modules/parser.js

/**
 * Возвращает все карточки видео, исключая плейлисты и коллекции.
 * Использует селекторы из старой, проверенной версии.
 * @returns {HTMLElement[]}
 */
function getVideoCards() {
    console.log("[Content Module Parser] Поиск карточек видео...");
    // Используем селектор из старого рабочего кода
    const allPotentialCards = Array.from(document.querySelectorAll('.yt-lockup-view-model'));
    console.log(`[Content Module Parser] Найдено потенциальных карточек до фильтрации: ${allPotentialCards.length}`);

    const filteredCards = allPotentialCards.filter(el => {
        // Фильтруем по тем же критериям
        const isCollectionStack2 = el.classList.contains('yt-lockup-view-model--collection-stack-2');
        const isCollection = el.classList.contains('yt-lockup-view-model--collection');
        const hasCollectionThumbnail = !!el.querySelector('yt-collection-thumbnail-view-model');
        const hasCollectionsStack = !!el.querySelector('yt-collections-stack');
        const isPlaylist = el.querySelector('a[href*="/watch"]')?.href.includes('list=');

        const shouldBeExcluded = isCollectionStack2 || isCollection || hasCollectionThumbnail || hasCollectionsStack || isPlaylist;

        // Для отладки, выведем информацию о том, что именно фильтруется
        // if (shouldBeExcluded) {
        //     console.log("[Content Module Parser] Исключена карточка:", { isCollectionStack2, isCollection, hasCollectionThumbnail, hasCollectionsStack, isPlaylist });
        // }

        return !shouldBeExcluded;
    });

    console.log(`[Content Module Parser] Найдено карточек видео после фильтрации: ${filteredCards.length}`);
    return filteredCards;
}

/**
 * Проверяет, подсвечена ли карточка или её родитель.
 * @param {HTMLElement} el
 * @returns {boolean}
 */
function isAlreadyHighlightedOrHasHighlightedParent(el) {
    if (el.classList.contains('video-highlighted')) return true;
    let parent = el.parentElement;
    while (parent) {
        if (parent.classList?.contains('video-highlighted')) return true;
        parent = parent.parentElement;
    }
    return false;
}

/**
 * Добавляет визуальную подсветку к элементу.
 * @param {HTMLElement} el
 */
function highlightElement(el) {
    // Проверка, не подсвечен ли уже элемент или его родитель
    if (isAlreadyHighlightedOrHasHighlightedParent(el)) {
        console.log("[Content Module Parser] Элемент уже подсвечен или находится внутри подсвеченного родителя, пропускаем.");
        return;
    }

    const box = document.createElement('div');
    Object.assign(box.style, {
        position: 'absolute',
        border: '3px solid #ff4d4d', // Используем тот же стиль, что и раньше
        pointerEvents: 'none',
        zIndex: '999999',
        borderRadius: '8px',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
        boxShadow: '0 0 8px rgba(255, 77, 77, 0.6)',
        boxSizing: 'border-box' // Добавляем для корректного размера рамки
    });

    // Убедиться, что контейнер имеет position для Absolute потомка
    const computedStyle = window.getComputedStyle(el);
    if (!computedStyle.position || computedStyle.position === 'static') {
        el.style.position = 'relative';
    }
    el.style.overflow = 'visible'; // Чтобы подсветка не обрезалась

    el.appendChild(box);
    el.classList.add('video-highlighted'); // Используем тот же класс
    console.log("[Content Module Parser] Элемент подсвечен.");
}

/**
 * Подсвечивает переданные карточки.
 * @param {HTMLElement[]} cards
 */
function highlightVideoCards(cards) {
    console.log(`[Content Module Parser] Начинаем подсвечивать ${cards.length} карточек...`);
    let highlightedCount = 0;
    cards.forEach(el => {
        try {
            highlightElement(el);
            highlightedCount++;
        } catch (err) {
            console.warn("[Content Module Parser] Ошибка при подсветке элемента:", err);
            // Не прерываем весь процесс из-за одной ошибки
        }
    });
    console.log(`[Content Module Parser] Успешно подсвечено карточек: ${highlightedCount}`);
}

/**
 * Находит и подсвечивает карточки видео на странице YouTube.
 * Возвращает массив найденных DOM-элементов, как требует логика.
 * @returns {HTMLElement[]} массив DOM-элементов карточек
 */
function parseAndHighlightVideoCards() {
    console.log("[Content Module Parser] === Начинаем парсинг и подсветку видео ===");

    // 1. Найти все подходящие карточки
    const cards = getVideoCards();
    console.log(`[Content Module Parser] Найдено карточек для подсветки: ${cards.length}`);

    // Для отладки: выведем первые несколько элементов
    console.log("[Content Module Parser] Первые 3 найденных элемента:", cards.slice(0, 3));

    // 2. Подсветить их
    highlightVideoCards(cards);

    console.log(`[Content Module Parser] === Парсинг и подсветка завершены. Возвращено элементов: ${cards.length} ===`);
    // 3. Вернуть массив найденных и подсвеченных элементов
    return cards;
}

/**
 * Удаляет подсветку, добавленную parseAndHighlightVideoCards.
 */
function removeParserHighlights() {
    console.log("[Content Module Parser] Удаление подсветки...");
    const highlightedCards = document.querySelectorAll('.video-highlighted');
    let removedCount = 0;
    highlightedCards.forEach(card => {
        // Удаляем только наш элемент подсветки (рамку)
        // Ищем div с характерными стилями
        const highlightBoxes = card.querySelectorAll('div[style*="border: 3px solid"]');
        highlightBoxes.forEach(box => {
            box.remove();
            removedCount++;
        });
        card.classList.remove('video-highlighted');
    });
    console.log(`[Content Module Parser] Удалено ${removedCount} элементов подсветки из ${highlightedCards.length} подсвеченных карточек.`);
}

// Экспортируем функции в глобальную область видимости
window.ytParser = {
    parseAndHighlight: parseAndHighlightVideoCards,
    removeHighlights: removeParserHighlights,
    // Для отладки можно экспортировать и вспомогательные функции
    getVideoCards: getVideoCards
};

console.log("[Content Module Parser] Модуль загружен и готов.");

=== END FILE: D:\разработка\youtube-parser-os\content\modules\parser.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\content\modules\scraper.js ===

// content/modules/scraper.js

/**
 * Извлекает данные из массива DOM-элементов карточек.
 * @param {HTMLElement[]} cardElements - массив DOM-элементов карточек (уже подсвеченных).
 * @param {string} sourceVideoId - ID видео, с которого был совершен переход (текущее видео).
 * @returns {Array<Object>} массив объектов с данными.
 *   Каждый объект содержит: title, videoId, views, channelName, sourceVideoId, thumbnailUrl.
 */
function scrapeCardsFromElements(cardElements, sourceVideoId = 'unknown') {
    console.log(`[Content Module Scraper] Начинаем скрапинг данных из ${cardElements.length} карточек...`);
    const scrapedData = [];

    cardElements.forEach((el, index) => {
        try {
            // --- Извлечение данных из элемента `el` ---
            // Структура HTML может немного отличаться, поэтому селекторы могут потребовать корректировки.

            // 1. Название видео
            // Оригинал: .yt-lockup-metadata-view-model__title
            // Новый вариант (на основе предоставленного HTML):
            const titleElement = el.querySelector('h3.yt-lockup-metadata-view-model__heading-reset a.yt-lockup-metadata-view-model__title');
            // Альтернатива, если предыдущая не сработала:
            // const titleElement = el.querySelector('.yt-lockup-metadata-view-model__title');
            const title = titleElement?.textContent?.trim() || 'Без названия';

            // 2. ID видео из ссылки
            let videoId = 'Не найден';
            // const linkElement = el.querySelector('a[href*="/watch?v="]');
            // Более общий селектор для ссылки на видео внутри карточки
            const linkElement = el.querySelector('a[href^="/watch?v="]');
            if (linkElement) {
                try {
                    const url = new URL(linkElement.href, window.location.origin);
                    videoId = url.searchParams.get('v') || 'Не найден';
                } catch (e) {
                    console.warn(`[Content Module Scraper] Ошибка парсинга URL для карточки ${index}:`, e);
                }
            }

            // 3. Количество просмотров
            let views = 'Неизвестно';
            // Ищем строку метаданных, которая содержит информацию о просмотрах
            const metadataRows = el.querySelectorAll('.yt-content-metadata-view-model__metadata-row');
            for (const row of metadataRows) {
                const rowText = row.textContent || '';
                // Проверяем на наличие просмотров (английский и русский), игнорируя дату после "•"
                // Пример: "21M views • 5 days ago" -> "21M views"
                if (/\b\d+([\.,]?\d+)*\s*[KMBkmb]?\.?\s*(views?|просмотра?|просмотров)/i.test(rowText)) {
                    // Берем текст до первого "•" и убираем лишнее
                    const viewsPart = rowText.split('•')[0].trim();
                    views = viewsPart;
                    break; // Нашли, выходим
                }
            }

            // 4. Название канала
            let channelName = 'Неизвестен';
            // В предоставленном HTML канал находится внутри .yt-content-metadata-view-model__metadata-row
            // и выглядит как: ... ChessMaster <иконка верификации> ...
            // Нужно найти span/text непосредственно перед или после иконки, или просто текст до разделителя.
            const channelMetadataRow = Array.from(metadataRows).find(row =>
                row.querySelector('span.yt-core-attributed-string--link-inherit-color') &&
                !row.querySelector('span.yt-content-metadata-view-model__delimiter') // Исключаем строку с датой
            );

            if (channelMetadataRow) {
                // Берем первый span с именем канала
                const channelSpan = channelMetadataRow.querySelector('span.yt-core-attributed-string--link-inherit-color');
                if (channelSpan) {
                    // Убираем иконку верификации, если она внутри
                    const verifiedIcon = channelSpan.querySelector('.ytIconWrapperHost');
                    if (verifiedIcon) {
                        verifiedIcon.remove(); // Временно удаляем, чтобы не мешала textContent
                    }
                    channelName = channelSpan.textContent?.trim() || 'Неизвестен';
                    if (verifiedIcon) {
                        channelSpan.appendChild(verifiedIcon); // Возвращаем иконку на место
                    }
                } else {
                    // Если span не найден, берем весь текст строки и пытаемся извлечь имя
                    const fullText = channelMetadataRow.textContent || '';
                    // Простая эвристика: имя канала до первого "•"
                    const parts = fullText.split('•');
                    channelName = parts[0]?.trim() || 'Неизвестен';
                }
            }

            // 5. Thumbnail URL
            let thumbnailUrl = '';
            const thumbnailImg = el.querySelector('yt-thumbnail-view-model img.ytCoreImageHost');
            if (thumbnailImg && thumbnailImg.src) {
                thumbnailUrl = thumbnailImg.src;
            }

            // --- Сборка объекта данных ---
            const scrapedItem = {
                title,
                videoId,
                views,
                channelName,
                sourceVideoId, // Передается извне
                thumbnailUrl
            };

            scrapedData.push(scrapedItem);
            // Для отладки, можно логировать первые N элементов
            // if (index < 3) {
            //     console.log(`[Content Module Scraper] Данные из карточки ${index + 1}:`, scrapedItem);
            // }

        } catch (err) {
            console.error(`[Content Module Scraper] Ошибка при скрапинге карточки ${index}:`, err);
            // Добавляем запись об ошибке, чтобы не терять счет
            scrapedData.push({
                title: `Ошибка скрапинга ${index}`,
                videoId: '',
                views: '',
                channelName: '',
                sourceVideoId: sourceVideoId,
                thumbnailUrl: '',
                _scrapeError: err.message // Доп. поле для отладки
            });
        }
    });

    console.log(`[Content Module Scraper] Скрапинг завершён. Извлечено данных: ${scrapedData.length}`);
    return scrapedData;
}

// Экспортируем функцию в глобальную область видимости
window.ytScraper = {
    scrapeCards: scrapeCardsFromElements
};

console.log("[Content Module Scraper] Модуль загружен и готов.");

=== END FILE: D:\разработка\youtube-parser-os\content\modules\scraper.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\content\modules\scroller.js ===

// content/modules/scroller.js

/**
 * Выполняет один шаг скроллинга страницы.
 * @param {number} step - На сколько пикселей скроллить.
 * @returns {Promise<void>}
 */
function performSingleScroll(step = 1000) {
    return new Promise((resolve) => {
        // Выполняем скролл
        window.scrollBy(0, step);
        // Небольшая задержка, чтобы дать странице немного отреагировать
        // Это может помочь, если YouTube подгружает контент лениво
        setTimeout(() => {
            console.log(`[Content Module Scroller] Выполнен один скролл на ${step}px.`);
            resolve();
        }, 50); // Небольшая задержка 50мс
    });
}

// Экспортируем функцию в глобальную область видимости
// Теперь она будет доступна как window.performSingleScroll
window.performSingleScroll = performSingleScroll;

console.log("[Content Module Scroller] Модуль загружен и готов.");

=== END FILE: D:\разработка\youtube-parser-os\content\modules\scroller.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\content\modules\video-checker.js ===

// content/modules/video-checker.js

/**
 * Проверяет, доступно ли текущее видео на странице YouTube.
 * Выполняется в контексте content script.
 * @returns {Promise<boolean>} true, если видео доступно, false - если недоступно или не на странице видео.
 */
function isCurrentVideoAvailable() {
    console.log("[Content Module VideoChecker] Начало проверки доступности видео.");

    try {
        // 1. Проверяем URL - часто недоступные видео имеют специальный URL
        if (window.location.pathname === '/unavailable') {
            console.log("[Content Module VideoChecker] Обнаружен URL /unavailable.");
            return false;
        }

        // 2. Ищем основной элемент плеера или контейнер видео
        const playerElement = document.querySelector('#player, ytd-watch-flexy');
        if (!playerElement) {
            console.log("[Content Module VideoChecker] Не найден основной элемент плеера или watch-flexy.");
            // Это может быть не страница видео, но мы проверяем дальше
        }

        // 3. Ищем специфичный элемент-индикатор недоступности
        // На основе предоставленного HTML
        const promoRenderer = document.querySelector('ytd-background-promo-renderer');
        if (promoRenderer) {
            const titleElement = promoRenderer.querySelector('.promo-title');
            const titleText = titleElement?.textContent?.trim().toLowerCase() || '';

            const bodyTextElement = promoRenderer.querySelector('.promo-body-text');
            const bodyText = bodyTextElement?.textContent?.trim().toLowerCase() || '';

            // Список известных фраз недоступности
            const unavailableIndicators = [
                'video unavailable',
                'this video is private',
                'this video is unavailable',
                'this video has been removed',
                'video заблокирован',
                'видео удалено',
                'видео недоступно'
                // Можно добавить больше на других языках
            ];

            const isUnavailableTitle = unavailableIndicators.some(phrase => titleText.includes(phrase.toLowerCase()));
            const isUnavailableBody = unavailableIndicators.some(phrase => bodyText.includes(phrase.toLowerCase()));

            if (isUnavailableTitle || isUnavailableBody) {
                console.log(`[Content Module VideoChecker] Найдена плашка недоступности. Заголовок: '${titleText}', Тело: '${bodyText}'`);
                return false;
            }
        }

        // 4. Проверяем наличие сообщений об ограничениях (например, возрастные ограничения)
        // Это более сложная проверка, оставим на потом или если потребуется

        // 5. Если не найдены явные признаки недоступности, считаем видео доступным
        // (или на другой странице, но это не ошибка "недоступности")
        console.log("[Content Module VideoChecker] Признаки недоступности видео не найдены. Считаем доступным.");
        return true;

    } catch (err) {
        console.error("[Content Module VideoChecker] Ошибка при проверке доступности видео:", err);
        // В случае ошибки проверки, лучше считать видео доступным, чтобы не блокировать работу
        return true;
    }
}

// Экспортируем функцию в глобальную область видимости для вызова из content.js
window.ytVideoChecker = {
    isCurrentVideoAvailable: isCurrentVideoAvailable
};

console.log("[Content Module VideoChecker] Модуль загружен и готов.");

=== END FILE: D:\разработка\youtube-parser-os\content\modules\video-checker.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\data-processor.js ===

// core/data-processor.js

/**
 * @typedef {import('./types/table.types.js').VideoData} VideoData
 */

/**
 * Подготавливает индексы и структуры данных из массива видео (например, импортированных).
 * @param {VideoData[]} videoDataArray - Массив объектов видео.
 * @returns {Object} Объект с подготовленными структурами.
 * @returns {Set<string>} .visitedVideoIds - Множество ID видео, НА КОТОРЫЕ УЖЕ ЗАХОДИЛИ (sourceVideoId).
 * @returns {Map<string, number>} .channelVideoCounts - Словарь: канал -> количество видео из этого канала.
 * @returns {Map<string, Set<string>>} .channelToVideoIds - Словарь: канал -> множество ID видео этого канала (videoId).
 */
export function prepareImportedDataIndices(videoDataArray) {
    // 1. Сет видео, на которые уже заходили (sourceVideoId)
    // Это видео, с которых был совершен переход, т.е. они уже были "текущими".
    const visitedVideoIds = new Set();

    // 2. Словарь: канал -> количество видео из этого канала
    const channelVideoCounts = new Map();

    // 3. Словарь: канал -> множество ID видео этого канала (videoId)
    const channelToVideoIds = new Map();

    if (!Array.isArray(videoDataArray)) {
        console.warn("[DataProcessor] Входные данные не являются массивом.");
        return { visitedVideoIds, channelVideoCounts, channelToVideoIds };
    }

    for (const video of videoDataArray) {
        // --- 1. Заполняем visitedVideoIds ---
        // ВАЖНО: Используем sourceVideoId, так как это ID видео,
        // на котором мы "останавливались" и с которого переходили.
        // Это предотвратит повторный переход на это же видео.
        if (video.sourceVideoId) {
            visitedVideoIds.add(video.sourceVideoId);
        }
        // Если нужно также отслеживать videoId (например, чтобы не добавлять дубликаты видео в таблицу),
        // можно добавить отдельный сет, например, allParsedVideoIds. Но для visitedVideoIds - это sourceVideoId.

        // --- 2. Заполняем channelVideoCounts ---
        const channel = video.channelName || 'Неизвестный канал';
        const currentCount = channelVideoCounts.get(channel) || 0;
        channelVideoCounts.set(channel, currentCount + 1);

        // --- 3. Заполняем channelToVideoIds ---
        // Здесь используем videoId, так как мы хотим знать, какие конкретные видео
        // принадлежат каналу.
        if (!channelToVideoIds.has(channel)) {
            channelToVideoIds.set(channel, new Set());
        }
        if (video.videoId) {
            channelToVideoIds.get(channel).add(video.videoId);
        }
    }

    return {
        visitedVideoIds,
        channelVideoCounts,
        channelToVideoIds
    };
}

=== END FILE: D:\разработка\youtube-parser-os\core\data-processor.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\index-manager.js ===

// core/index-manager.js

/**
 * Менеджер индексов для отслеживания состояния парсинга.
 * Управляет visitedVideoIds, channelVideoCounts, channelToVideoIds и scrapedData.
 */

// --- 1. Состояние (в памяти background.js) ---
/** @type {Set<string>} - Множество ID видео, на которые мы уже заходили (sourceVideoId). */
let visitedVideoIds = new Set();

/** @type {Map<string, number>} - Словарь: канал -> количество видео из этого канала. */
let channelVideoCounts = new Map();

/** @type {Map<string, Set<string>>} - Словарь: канал -> множество ID видео этого канала. */
let channelToVideoIds = new Map();

/** @type {Array<Object>} - Массив данных, извлеченных в ходе последнего парсинга. */
let scrapedDataBuffer = [];

// --- 2. API для работы с индексами ---

/**
 * Инициализирует индексы, опционально на основе начальных данных.
 * @param {Array<Object>} [initialData=[]] - Массив объектов видео (например, из tableAdapter.getAll()).
 * @returns {Promise<void>}
 */
export async function initialize(initialData = []) {
    console.log("[IndexManager] Инициализация индексов...");
    reset(); // Очищаем текущее состояние

    if (!Array.isArray(initialData) || initialData.length === 0) {
        console.log("[IndexManager] Нет начальных данных для инициализации индексов.");
        return;
    }

    console.log(`[IndexManager] Начинаем построение индексов из ${initialData.length} записей...`);
    let processedCount = 0;

    for (const video of initialData) {
        // --- visitedVideoIds: ID видео, на которые мы заходили (sourceVideoId) ---
        // Предполагаем, что если запись есть, то на это video.sourceVideoId мы уже заходили.
        if (video.sourceVideoId) {
            visitedVideoIds.add(video.sourceVideoId);
        }

        // --- channelVideoCounts: канал -> количество видео ---
        const channel = video.channelName || 'Неизвестный канал';
        const currentCount = channelVideoCounts.get(channel) || 0;
        channelVideoCounts.set(channel, currentCount + 1);

        // --- channelToVideoIds: канал -> множество ID видео ---
        if (!channelToVideoIds.has(channel)) {
            channelToVideoIds.set(channel, new Set());
        }
        if (video.videoId) {
            channelToVideoIds.get(channel).add(video.videoId);
        }

        processedCount++;
    }

    console.log(`[IndexManager] Индексы инициализированы. Обработано записей: ${processedCount}`);
    console.log(`[IndexManager] visitedVideoIds.size: ${visitedVideoIds.size}`);
    console.log(`[IndexManager] channelVideoCounts.size: ${channelVideoCounts.size}`);
    console.log(`[IndexManager] channelToVideoIds.size: ${channelToVideoIds.size}`);
}

/**
 * Сбрасывает все индексы и буфер в начальное состояние.
 */
export function reset() {
    console.log("[IndexManager] Сброс всех индексов и буфера.");
    visitedVideoIds.clear();
    channelVideoCounts.clear();
    channelToVideoIds.clear();
    scrapedDataBuffer = [];
    console.log("[IndexManager] Все индексы и буфер сброшены.");
}

/**
 * Добавляет новые данные в индексы и буфер.
 * @param {Array<Object>} newScrapedData - Массив новых объектов данных видео.
 */
export function addScrapedData(newScrapedData) {
    if (!Array.isArray(newScrapedData) || newScrapedData.length === 0) {
        console.warn("[IndexManager] addScrapedData: Получен пустой или некорректный массив данных.");
        return;
    }

    console.log(`[IndexManager] Добавление ${newScrapedData.length} новых записей в индексы и буфер.`);

    // 1. Добавляем в буфер
    scrapedDataBuffer.push(...newScrapedData);

    // 2. Обновляем индексы
    for (const video of newScrapedData) {
        // visitedVideoIds обновляется, если sourceVideoId является "посещенным"
        // Но в данном случае sourceVideoId - это видео, С КОТОРОГО мы пришли.
        // visitedVideoIds - это скорее ID видео, которые мы ПАРСИЛИ как источник.
        // Если мы хотим отслеживать, какие исходные видео мы уже обработали,
        // то sourceVideoId добавляется в visitedVideoIds.
        // Если мы хотим отслеживать, какие видео мы УЖЕ НАШЛИ (и не должны добавлять снова),
        // то videoId добавляется в отдельный индекс.
        // Для MVP: visitedVideoIds отслеживает sourceVideoId (откуда пришли).
        if (video.sourceVideoId) {
            visitedVideoIds.add(video.sourceVideoId);
        }

        // channelVideoCounts и channelToVideoIds обновляются для найденных видео
        const channel = video.channelName || 'Неизвестный канал';
        const currentCount = channelVideoCounts.get(channel) || 0;
        channelVideoCounts.set(channel, currentCount + 1);

        if (!channelToVideoIds.has(channel)) {
            channelToVideoIds.set(channel, new Set());
        }
        if (video.videoId) {
            channelToVideoIds.get(channel).add(video.videoId);
        }
    }

    console.log(`[IndexManager] Индексы обновлены. Новый размер буфера: ${scrapedDataBuffer.length}`);
    console.log(`[IndexManager] visitedVideoIds.size: ${visitedVideoIds.size}`);
    console.log(`[IndexManager] channelVideoCounts.size: ${channelVideoCounts.size}`);
    console.log(`[IndexManager] channelToVideoIds.size: ${channelToVideoIds.size}`);
    console.log("scrapedDataBuffer", scrapedDataBuffer);
    console.log("visitedVideoIds", visitedVideoIds);
    console.log("channelVideoCounts", channelVideoCounts);
    console.log("channelToVideoIds", channelToVideoIds);

}

/**
 * Получает текущее состояние всех индексов и буфера.
 * @returns {{ visitedVideoIds: Set<string>, channelVideoCounts: Map<string, number>, channelToVideoIds: Map<string, Set<string>>, scrapedDataBuffer: Array<Object> }}
 */
export function getStateSnapshot() {
    // Возвращаем копии, чтобы предотвратить внешнее мутирование внутреннего состояния
    return {
        visitedVideoIds: new Set(visitedVideoIds),
        channelVideoCounts: new Map(channelVideoCounts),
        channelToVideoIds: new Map(Array.from(channelToVideoIds, ([k, v]) => [k, new Set(v)])),
        scrapedDataBuffer: [...scrapedDataBuffer] // Копия массива
    };
}

/**
 * Получает текущий буфер извлеченных данных.
 * @returns {Array<Object>} Копия массива scrapedDataBuffer.
 */
export function getScrapedDataBuffer() {
    return [...scrapedDataBuffer];
}

/**
 * Очищает буфер извлеченных данных.
 */
export function clearScrapedDataBuffer() {
    console.log("[IndexManager] Очистка буфера извлеченных данных.");
    scrapedDataBuffer = [];
    console.log("[IndexManager] Буфер извлеченных данных очищен.");
}

// --- 3. Вспомогательные функции (по мере необходимости) ---

/**
 * Проверяет, был ли уже посещен указанный sourceVideoId.
 * @param {string} sourceVideoId
 * @returns {boolean}
 */
export function isSourceVisited(sourceVideoId) {
    return visitedVideoIds.has(sourceVideoId);
}

/**
 * Возвращает количество уникальных каналов, найденных в данных.
 * @returns {number}
 */
export function getUniqueChannelCount() {
    return channelVideoCounts.size;
}

/**
 * Возвращает общее количество уникальных видео, найденных в данных.
 * @returns {number}
 */
export function getTotalUniqueVideoCount() {
    // Суммируем количество уникальных видео по всем каналам
    let total = 0;
    for (const videoIdsSet of channelToVideoIds.values()) {
        total += videoIdsSet.size;
    }
    return total;
}

// Экспортируем также функции для получения самих структур, если нужно прямой доступ
// (но рекомендуется использовать getStateSnapshot для согласованности)
export { visitedVideoIds, channelVideoCounts, channelToVideoIds };

=== END FILE: D:\разработка\youtube-parser-os\core\index-manager.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\logger.js ===

// core/logger.js
import { ChromeStorageLogAdapter } from '../adapters/ChromeStorageLogAdapter.js';

/**
 * @typedef {import('./types/log.types.js').LogEntry} LogEntry
 * @typedef {import('./types/log.types.js').LoggerConfig} LoggerConfig
 * @typedef {import('./types/log.types.js').LogAdapter} LogAdapter
 * @typedef {import('./types/log.types.js').LogSubscriber} LogSubscriber
 */

export class Logger {
    /** @type {LogAdapter[]} */
    #adapters = [];
    /** @type {LogSubscriber[]} */
    #subscribers = [];
    /** @type {LoggerConfig} */
    #config;

    /**
     * @param {LoggerConfig} config
     */
    constructor(config = {}) {
        this.#config = {
            maxSize: config.maxSize ?? 1000,
            enableConsole: config.enableConsole ?? true,
            defaultLevel: config.defaultLevel ?? 'info',
        };

        // По умолчанию добавляем адаптер для Chrome Storage
        this.addAdapter(new ChromeStorageLogAdapter({ maxSize: this.#config.maxSize }));
    }

    /**
     * Добавляет адаптер для хранения/вывода логов.
     * @param {LogAdapter} adapter
     */
    addAdapter(adapter) {
        this.#adapters.push(adapter);
    }

    /**
     * Подписывается на новые логи и команды (например, очистка).
     * @param {LogSubscriber} callback
     */
    subscribe(callback) {
        this.#subscribers.push(callback);
    }

    /**
     * Отписывается от новых логов.
     * @param {LogSubscriber} callback
     */
    unsubscribe(callback) {
        this.#subscribers = this.#subscribers.filter(cb => cb !== callback);
    }

    /**
     * Создает и записывает лог-запись.
     * @param {string} message
     * @param {'debug'|'info'|'success'|'warn'|'error'} [level]
     * @param {Object} [options]
     * @param {string} [options.module]
     * @param {string} [options.contextId]
     * @param {Object} [options.meta]
     */
    async log(message, level = this.#config.defaultLevel, options = {}) {
        const entry = {
            id: this.#generateId(),
            timestamp: Date.now(),
            level,
            message,
            module: options.module,
            contextId: options.contextId,
            meta: options.meta,
        };

        // 1. Запись через адаптеры
        const writePromises = this.#adapters.map(adapter => adapter.write(entry));
        await Promise.allSettled(writePromises); // Не прерываемся из-за ошибки одного адаптера

        // 2. Дублирование в консоль (если включено)
        if (this.#config.enableConsole) {
            this.#logToConsole(entry);
        }

        // 3. Уведомление подписчиков
        this.#notifySubscribers(entry);

        // 4. 👇 НОВОЕ: Отправка сообщения в popup (если в background)
        // Проверяем, что мы в Service Worker (background)
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            try {
                // Используем стрелочную функцию для правильного контекста this
                chrome.runtime.sendMessage({
                    type: "newLog",
                    log: entry
                }).catch(err => {
                    // Это обработка ошибки асинхронной операции sendMessage
                    if (chrome.runtime.lastError) {
                        // Это нормально, если popup закрыт
                        // console.debug("Popup недоступен для sendMessage:", chrome.runtime.lastError.message);
                    } else {
                        console.debug("Ошибка при отправке лога в popup (асинхронная):", err);
                    }
                });
            } catch (syncSendError) {
                // Это обработка синхронной ошибки при вызове sendMessage
                // Может возникнуть, если API недоступен в текущем контексте (редко)
                console.debug("Синхронная ошибка при вызове sendMessage:", syncSendError);
            }
        }
    }

    /**
     * Получает все логи из всех адаптеров (берет из первого доступного).
     * @returns {Promise<LogEntry[]>}
     */
    async getAllLogs() {
        for (const adapter of this.#adapters) {
            try {
                const logs = await adapter.read();
                return logs;
            } catch (e) {
                console.warn("[Logger] Не удалось получить логи из адаптера:", e);
            }
        }
        return []; // Если ни один адаптер не сработал
    }

    /**
     * Очищает логи во всех адаптерах.
     * @returns {Promise<void>}
     */
    async clear() {
        const clearPromises = this.#adapters.map(adapter => adapter.clear());
        await Promise.allSettled(clearPromises);
        // Уведомляем подписчиков об очистке
        this.#notifySubscribers({ type: 'CLEAR_LOGS' });
    }

    // --- Вспомогательные методы ---

    /**
     * Удобные методы для разных уровней
     */
    debug(message, options = {}) { return this.log(message, 'debug', options); }
    info(message, options = {}) { return this.log(message, 'info', options); }
    success(message, options = {}) { return this.log(message, 'success', options); }
    warn(message, options = {}) { return this.log(message, 'warn', options); }
    error(message, options = {}) { return this.log(message, 'error', options); }

    /**
     * Генерирует уникальный ID для записи.
     * @returns {string}
     */
    #generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Выводит лог в консоль браузера.
     * @param {LogEntry} entry
     */
    #logToConsole(entry) {
        const time = new Date(entry.timestamp).toLocaleTimeString();
        const prefix = `[${time}] [${entry.level.toUpperCase()}]`;
        const suffix = entry.module ? `[${entry.module}]` : '';
        const context = entry.contextId ? `(ctx:${entry.contextId})` : '';

        const consoleMethod = entry.level === 'error' ? console.error :
            entry.level === 'warn' ? console.warn :
                entry.level === 'debug' ? console.debug : console.log;

        consoleMethod(`${prefix} ${entry.message} ${suffix} ${context}`, entry.meta || '');
    }

    /**
     * Уведомляет всех подписчиков.
     * @param {LogEntry | { type: 'CLEAR_LOGS' }} entry
     */
    #notifySubscribers(entry) {
        this.#subscribers.forEach(callback => {
            try {
                callback(entry);
            } catch (e) {
                console.error("[Logger] Ошибка в подписчике:", e);
            }
        });
    }
}

=== END FILE: D:\разработка\youtube-parser-os\core\logger.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\scenario-engine.js ===


// core/scenario-engine.js
import { logger } from '../background/background.js'; // Импортируем логгер

/**
 * @typedef {import('./types/scenario.types.js').ScenarioDefinition} ScenarioDefinition
 * @typedef {import('./types/scenario.types.js').ScenarioContext} ScenarioContext
 */

export class ScenarioEngine {
    /** @type {Map<string, { definition: ScenarioDefinition, context: ScenarioContext, controller: AbortController }>} */
    #runningScenarios = new Map();

    /**
     * Регистрирует сценарий в движке.
     * @param {ScenarioDefinition} scenarioDefinition
     */
    registerScenario(scenarioDefinition) {
        // В будущем можно хранить определения для UI/выбора
        // Пока просто логируем регистрацию
        logger.debug(`[ScenarioEngine] Зарегистрирован сценарий: ${scenarioDefinition.name}`, { module: 'ScenarioEngine' });
    }

    /**
     * Запускает сценарий.
     * @param {ScenarioDefinition} scenarioDefinition
     * @param {Object} [params={}] - Параметры для сценария.
     * @param {number} [tabId] - ID вкладки, если применимо.
     * @returns {Promise<string>} ID запущенного экземпляра сценария.
     */

    async run(scenarioDefinition, params = {}, tabId = null) {
        const instanceId = this.#generateId();
        const controller = new AbortController();
        console.log(`[ScenarioEngine] Начало запуска сценария ${scenarioDefinition.id}, tabId:`, tabId); // <-- Лог

        /** @type {ScenarioContext} */
        const context = {
            id: instanceId,
            tabId,
            params,
            log: (message, options = {}) => {
                logger.info(message, {
                    module: options.module || `Scenario:${scenarioDefinition.id}`,
                    contextId: instanceId,
                    ...options
                });
            },
            abortSignal: async () => {
                return new Promise((resolve, reject) => {
                    // 1. Проверка, не сработал ли сигнал уже
                    if (controller.signal.aborted) {
                        // Если сработал, немедленно ОТКЛОНЯЕМ промис
                        reject(new Error('Сценарий остановлен пользователем.'));
                        return;
                    }
                    // 2. Если сигнал еще не сработал, ставим слушатель
                    controller.signal.addEventListener('abort', () => {
                        // Когда controller.abort() будет вызван, ОТКЛАНИМ промис
                        reject(new Error('Сценарий остановлен пользователем.'));
                    }, { once: true });

                    // 3. !!!КЛЮЧЕВОЕ ИЗМЕНЕНИЕ!!!
                    // Если сигнал еще не сработал, это означает, что остановки нет.
                    // Следовательно, abortSignal должен УСПЕШНО ЗАВЕРШИТЬСЯ.
                    // Мы не ждем "реального" события abort, мы просто сообщаем,
                    // что на данный момент остановки нет.
                    resolve(); // <-- УСПЕШНО РАЗРЕШАЕМ промис
                });
            },
            // Передаем контроллер в контекст, чтобы получить к нему доступ в finally
            controller: controller
        };

        this.#runningScenarios.set(instanceId, { definition: scenarioDefinition, context, controller });

        // 👇 Уведомляем popup о начале сценария
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            chrome.runtime.sendMessage({
                type: "scenarioStatus",
                status: "started",
                message: `[ScenarioEngine] Запуск сценария "${scenarioDefinition.name}" (ID: ${instanceId})`,
                level: "info"
            }).catch(err => {
                console.debug("Не удалось отправить сообщение о начале сценария в popup:", err);
            });
        }

        context.log(`[ScenarioEngine] Запуск сценария "${scenarioDefinition.name}" (ID: ${instanceId})`, { module: 'ScenarioEngine' });

        try {
            await scenarioDefinition.execute(context);
            context.log(`[ScenarioEngine] Сценарий "${scenarioDefinition.name}" успешно завершен.`, { module: 'ScenarioEngine' });
        } catch (error) {
            if (error.message === 'Сценарий остановлен пользователем.') {
                context.log(`[ScenarioEngine] Сценарий "${scenarioDefinition.name}" остановлен пользователем.`, { module: 'ScenarioEngine', level: 'warn' });
            } else {
                context.log(`[ScenarioEngine] Ошибка в сценарии "${scenarioDefinition.name}": ${error.message}`, { module: 'ScenarioEngine', level: 'error' });
                logger.error(`Ошибка в сценарии "${scenarioDefinition.name}": ${error.stack}`, { module: 'ScenarioEngine', contextId: instanceId });
            }
        } finally {
            this.#runningScenarios.delete(instanceId);

            // 👇 Уведомляем popup о завершении сценария
            // Теперь мы можем получить доступ к controller через context
            const isAborted = context.controller.signal.aborted;
            const finalStatus = isAborted ? "stopped" : "finished";
            const finalMessage = isAborted ?
                `[ScenarioEngine] Сценарий "${scenarioDefinition.name}" (ID: ${instanceId}) был остановлен.` :
                `[ScenarioEngine] Сценарий "${scenarioDefinition.name}" (ID: ${instanceId}) завершен.`;

            console.log(`[ScenarioEngine] Отправка финального статуса "${finalStatus}" для сценария ID: ${instanceId}`); // <-- Лог

            if (typeof chrome !== 'undefined' && chrome.runtime) {
                chrome.runtime.sendMessage({
                    type: "scenarioStatus",
                    status: finalStatus,
                    message: finalMessage,
                    level: "info"
                }).catch(err => {
                    console.debug("Не удалось отправить сообщение о завершении сценария в popup:", err);
                });
            }
            console.log(`[ScenarioEngine] Финальный статус "${finalStatus}" для сценария ID: ${instanceId} отправлен (или попытка отправки завершена).`); // <-- Лог
        }
        return instanceId;
    }

    /**
     * Останавливает запущенный сценарий.
     * @param {string} instanceId
     * @returns {boolean} true, если сценарий был найден и остановлен.
     */
    stop(instanceId) {
        const scenarioInstance = this.#runningScenarios.get(instanceId);
        if (scenarioInstance) {
            scenarioInstance.controller.abort();
            scenarioInstance.context.log(`[ScenarioEngine] Запрошена остановка сценария.`, { module: 'ScenarioEngine', level: 'warn' });
            return true;
        }
        logger.warn(`[ScenarioEngine] Попытка остановить несуществующий сценарий (ID: ${instanceId})`, { module: 'ScenarioEngine' });
        return false;
    }

    /**
     * Возвращает список запущенных сценариев.
     * @returns {Array<{id: string, name: string}>}
     */
    getRunningScenarios() {
        return Array.from(this.#runningScenarios.entries()).map(([id, { definition }]) => ({
            id,
            name: definition.name
        }));
    }

    /**
     * Генерирует уникальный ID для экземпляра сценария.
     * @returns {string}
     */
    #generateId() {
        return `scenario_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}



=== END FILE: D:\разработка\youtube-parser-os\core\scenario-engine.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\types\log.types.js ===

// core/types/log.types.js

/**
 * @typedef {Object} LogEntry
 * @property {string} id - Уникальный идентификатор записи.
 * @property {number} timestamp - Временная метка (мс с 1970).
 * @property {string} level - Уровень лога: 'debug', 'info', 'success', 'warn', 'error'.
 * @property {string} message - Текст сообщения.
 * @property {string} [module] - Модуль или компонент, создавший запись (например, 'Parser', 'Selector').
 * @property {string} [contextId] - Идентификатор контекста (например, ID сессии анализа).
 * @property {Object} [meta] - Дополнительные данные.
 */

/**
 * @typedef {Object} LoggerConfig
 * @property {number} [maxSize=1000] - Максимальное количество записей в памяти/хранилище.
 * @property {boolean} [enableConsole=true] - Дублировать логи в console.
 * @property {string} [defaultLevel='info'] - Уровень логирования по умолчанию.
 */

/**
 * @callback LogSubscriber
 * @param {LogEntry | { type: 'CLEAR_LOGS' }} entry - Запись лога или команда очистки.
 * @returns {void}
 */

/**
 * @typedef {Object} LogAdapter
 * @property {function(LogEntry): Promise<void>} write - Записывает лог.
 * @property {function(): Promise<LogEntry[]>} read - Читает все логи.
 * @property {function(): Promise<void>} clear - Очищает логи.
 */

=== END FILE: D:\разработка\youtube-parser-os\core\types\log.types.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\types\scenario.types.js ===

// core/types/scenario.types.js

/**
 * @typedef {Object} ScenarioContext
 * @property {string} id - Уникальный идентификатор выполнения сценария.
 * @property {number} [tabId] - ID активной вкладки, если применимо.
 * @property {Object} [params] - Параметры, переданные сценарию.
 * @property {function(string, Object): void} log - Функция для логирования в контексте сценария.
 * @property {function(): Promise<void>} abortSignal - Функция для проверки, не был ли запрос на остановку.
 */

/**
 * @typedef {Object} ScenarioDefinition
 * @property {string} id - Уникальный идентификатор сценария.
 * @property {string} name - Человекочитаемое имя сценария.
 * @property {string} description - Описание сценария.
 * @property {function(ScenarioContext): Promise<void>} execute - Асинхронная функция выполнения сценария.
 */

=== END FILE: D:\разработка\youtube-parser-os\core\types\scenario.types.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\types\table.types.js ===

// core/types/table.types.js

/**
 * @typedef {Object} VideoData
 * @property {string} videoId - Уникальный идентификатор видео.
 * @property {string} title - Название видео.
 * @property {string} channelName - Название канала.
 * @property {string} views - Количество просмотров (в виде строки, например, "1.2M").
 * @property {string} sourceVideoId - ID видео, с которого был совершен переход.
 * @property {string} thumbnailUrl - URL миниатюры.
 * @property {number} timestamp - Временная метка добавления записи.
 * @property {boolean} [isImported] - Флаг, указывающий, что запись была импортирована.
 */

/**
 * @typedef {Object} TableAdapter
 * @property {function(VideoData): Promise<void>} add - Добавляет одну запись.
 * @property {function(VideoData[]): Promise<void>} addBatch - Добавляет несколько записей.
 * @property {function(): Promise<VideoData[]>} getAll - Получает все записи.
 * @property {function(): Promise<void>} clear - Очищает таблицу.
 * @property {function(): Promise<number>} getCount - Получает общее количество записей.
 */

=== END FILE: D:\разработка\youtube-parser-os\core\types\table.types.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\utils\blacklist.js ===

// core/utils/blacklist.js

const BLACKLIST_STORAGE_KEY = 'unavailableVideoIds';

/**
 * Получает Set недоступных videoId из хранилища.
 * @returns {Promise<Set<string>>} Множество недоступных ID.
 */
export async function getUnavailableVideoIds() {
    try {
        const result = await chrome.storage.local.get([BLACKLIST_STORAGE_KEY]);
        const idsArray = result[BLACKLIST_STORAGE_KEY] || [];
        return new Set(idsArray);
    } catch (e) {
        console.error("[Blacklist] Ошибка получения черного списка:", e);
        return new Set(); // Возвращаем пустой Set в случае ошибки
    }
}

/**
 * Добавляет один или несколько videoId в черный список.
 * @param {string | string[]} videoIds - ID видео или массив ID.
 * @returns {Promise<void>}
 */
export async function addUnavailableVideoIds(videoIds) {
    const idsToAdd = Array.isArray(videoIds) ? videoIds : [videoIds];
    if (idsToAdd.length === 0) return;

    try {
        const currentSet = await getUnavailableVideoIds();
        let changed = false;

        idsToAdd.forEach(id => {
            if (id && !currentSet.has(id)) {
                currentSet.add(id);
                changed = true;
            }
        });

        if (changed) {
            const newArray = Array.from(currentSet);
            await chrome.storage.local.set({ [BLACKLIST_STORAGE_KEY]: newArray });
            console.log(`[Blacklist] Добавлено ${idsToAdd.length} ID в черный список. Общий размер: ${newArray.length}`);
        } else {
            console.log("[Blacklist] Нет новых ID для добавления в черный список.");
        }
    } catch (e) {
        console.error("[Blacklist] Ошибка добавления в черный список:", e);
        throw e; // Пробрасываем ошибку для обработки выше
    }
}

/**
 * Проверяет, находится ли конкретный videoId в черном списке.
 * @param {string} videoId - ID видео.
 * @returns {Promise<boolean>}
 */
export async function isVideoUnavailable(videoId) {
    if (!videoId) return false;
    const blacklistSet = await getUnavailableVideoIds();
    return blacklistSet.has(videoId);
}

=== END FILE: D:\разработка\youtube-parser-os\core\utils\blacklist.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\utils\parser.js ===

// core/utils/parser.js

/**
 * Отправляет сообщение в content script для парсинга и подсветки видео.
 * @param {Object} context - Контекст сценария (для tabId и логов).
 * @returns {Promise<{status: string, highlightedCards?: HTMLElement[], highlightedCount?: number, message?: string}>}
 * ВАЖНО: DOM-элементы нельзя передавать через sendMessage, они становятся пустыми объектами {}.
 * Поэтому возвращаем только количество. Для получения самих данных будет следующий шаг (scraping).
 */
export async function parseAndHighlight(context) {
    const { log, tabId } = context;
    // Предполагается, что sourceVideoId будет доступен в context
    // Это может быть ID текущей вкладки, если мы на странице видео, или передано специально.
    // Для MVP возьмем его из URL вкладки или используем заглушку.
    let sourceVideoId = 'unknown_source';
    try {
        if (typeof tabId === 'number' && tabId > 0) {
            const tab = await chrome.tabs.get(tabId);
            const url = new URL(tab.url);
            sourceVideoId = url.searchParams.get('v') || 'unknown_source_from_url';
        }
    } catch (getUrlErr) {
        console.warn("[Core Parser] Не удалось получить sourceVideoId из URL вкладки:", getUrlErr);
        sourceVideoId = 'unknown_source';
    }

    // Переопределяем sourceVideoId, если он передан явно в params (например, из сценария навигации)
    if (context.params && context.params.sourceVideoId) {
        sourceVideoId = context.params.sourceVideoId;
    }

    if (typeof tabId !== 'number' || tabId < 0) {
        const errorMsg = `Недействительный tabId для парсинга: ${tabId}`;
        log(`❌ ${errorMsg}`, { module: 'Parser', level: 'error' });
        throw new Error(errorMsg);
    }

    log(`🔍 Отправка запроса на парсинг, подсветку и скрапинг видео (источник: ${sourceVideoId})...`, { module: 'Parser' });

    try {
        const response = await chrome.tabs.sendMessage(tabId, {
            action: "parseAndHighlight",
            sourceVideoId: sourceVideoId // Передаем sourceVideoId в content script
        });

        if (response && response.status === "success") {
            const count = response.highlightedCount;
            const data = response.scrapedData || [];
            log(`✅ Парсинг, подсветка и скрапинг завершены. Найдено/подсвечено видео: ${count}, извлечено данных: ${data.length}`, { module: 'Parser' });

            // Выводим в консоль background первые N записей для проверки
            const itemsToShow = Math.min(3, data.length);
            if (itemsToShow > 0) {
                console.group(`[Core Parser] Данные первых ${itemsToShow} извлеченных карточек:`);
                for (let i = 0; i < itemsToShow; i++) {
                    const item = data[i];
                    console.log(
                        `Карточка ${i + 1}:`,
                        `ID: ${item.videoId || 'N/A'}`,
                        `Название: "${(item.title || 'N/A').substring(0, 50)}${(item.title || '').length > 50 ? '...' : ''}"`,
                        `Канал: "${(item.channelName || 'N/A').substring(0, 30)}${(item.channelName || '').length > 30 ? '...' : ''}"`
                    );
                }
                console.groupEnd();
            }

            return response; // { status: "success", highlightedCount: number, scrapedData: Array }
        } else {
            const errorMsg = response?.message || "Неизвестная ошибка парсинга/подсветки/скрапинга";
            log(`❌ Ошибка парсинга/подсветки/скрапинга: ${errorMsg}`, { module: 'Parser', level: 'error' });
            throw new Error(errorMsg);
        }
    } catch (err) {
        log(`❌ Ошибка связи при парсинге/подсветке/скрапинге: ${err.message}`, { module: 'Parser', level: 'error' });
        throw err; // Пробрасываем для обработки выше
    }
}

/**
 * Отправляет сообщение в content script для удаления подсветки.
 * @param {Object} context - Контекст сценария (для tabId и логов).
 * @returns {Promise<void>}
 */
export async function removeParserHighlights(context) {
    const { log, tabId } = context;

    if (typeof tabId !== 'number' || tabId < 0) {
        // Не критично, просто логируем
        console.warn("[Core Parser] Недействительный tabId для удаления подсветки:", tabId);
        return;
    }

    log(`🧹 Отправка запроса на удаление подсветки...`, { module: 'Parser' });

    try {
        const response = await chrome.tabs.sendMessage(tabId, {
            action: "removeParserHighlights"
        });

        if (response && response.status === "success") {
            log(`✅ Подсветка удалена.`, { module: 'Parser' });
        } else {
            const errorMsg = response?.message || "Неизвестная ошибка удаления подсветки";
            log(`⚠️ Ошибка удаления подсветки: ${errorMsg}`, { module: 'Parser', level: 'warn' });
            // Не бросаем ошибку, так как это вспомогательная операция
        }
    } catch (err) {
        // Может возникнуть, если вкладка закрыта
        log(`⚠️ Ошибка связи при удалении подсветки: ${err.message}`, { module: 'Parser', level: 'warn' });
    }
}

=== END FILE: D:\разработка\youtube-parser-os\core\utils\parser.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\utils\scroller.js ===

// core/utils/scroller.js

/**
 * Выполняет N шагов скроллинга страницы с задержками и отслеживанием прогресса.
 * @param {Object} context - Контекст сценария для логирования и проверки прерывания.
 * @param {number} [count=16] - Сколько раз скроллить.
 * @param {number} [delayMs=1500] - Задержка между скроллами (мс).
 * @param {number} [step=1000] - На сколько пикселей скроллить за раз.
 * @returns {Promise<void>}
 */
export async function scrollPageNTimes(context, count = 16, delayMs = 1500, step = 1000) {
    const { log, abortSignal } = context;
    let tabId = context.tabId;
    console.log("[Scroller] scrollPageNTimes вызвана с параметрами:", { count, delayMs, step, tabId: context.tabId }); // <-- Лог
    log(`🔄 Начинаем скроллинг страницы: ${count} раз(а), шаг ${step}px, задержка ${delayMs}мс`, { module: 'Scroller' });

    try {

        // --- УЛУЧШЕННАЯ ПРОВЕРКА tabId ---
        // 1. Сначала проверяем, передан ли tabId в context
        let effectiveTabId = tabId;

        // 2. Если tabId все еще null/undefined, логируем предупреждение
        // (Это может произойти, если background.js не смог его получить)
        if (effectiveTabId == null) { // == проверит и null, и undefined
            const errorMsg = `Недействительный tabId для sendMessage: ${effectiveTabId}. Убедитесь, что сценарий запущен на активной вкладке YouTube.`;
            log(`❌ ${errorMsg}`, { module: 'Scroller', level: 'error' });
            throw new Error(errorMsg); // Прерываем выполнение скроллинга
        }

        // 3. Проверка типа (дополнительная предосторожность)
        if (typeof effectiveTabId !== 'number' || effectiveTabId < 0) {
            const errorMsg = `Недействительный тип или значение tabId для sendMessage: ${effectiveTabId} (тип: ${typeof effectiveTabId}). Ожидалось положительное число.`;
            log(`❌ ${errorMsg}`, { module: 'Scroller', level: 'error' });
            throw new Error(errorMsg);
        }
        // --- КОНЕЦ УЛУЧШЕННОЙ ПРОВЕРКИ tabId ---
        console.log("Проверка tabId пройдена", effectiveTabId);
        for (let i = 1; i <= count; i++) {
            console.log("// 1. Проверяем, не был ли запрос на остановку/прерывание");
            // 1. Проверяем, не был ли запрос на остановку/прерывание
            await abortSignal();

            // 2. Отправляем сообщение content script для выполнения ОДНОГО скролла
            log(`⏳ Выполняем скролл ${i}/${count}...`, { module: 'Scroller' });

            // --- ПОПЫТКА С БЛОКОМ try/catch ДЛЯ sendMessage ---
            let response;
            try {
                response = await chrome.tabs.sendMessage(
                    context.tabId,
                    {
                        action: "performSingleScroll",
                        step: step
                    }
                );
            } catch (sendMsgErr) {
                log(`❌ Ошибка sendMessage для скролла ${i}/${count}: ${sendMsgErr.message}`, { module: 'Scroller', level: 'error' });
                throw new Error(`Ошибка связи со страницей YouTube: ${sendMsgErr.message}`);
            }
            // --- КОНЕЦ ПОПЫТКИ ---

            if (response && response.status === "success") {
                log(`✅ Скролл ${i}/${count} выполнен.`, { module: 'Scroller' });
            } else {
                const errorMsg = response?.message || "Неизвестная ошибка выполнения скролла";
                log(`❌ Ошибка скролла ${i}/${count}: ${errorMsg}`, { module: 'Scroller', level: 'error' });
                throw new Error(errorMsg);
            }

            // 3. Проверяем снова на прерывание после выполнения скролла
            await abortSignal();

            // 4. Если это не последний скролл, делаем паузу
            if (i < count) {
                log(`⏱️ Ожидание ${delayMs}мс перед следующим скроллом (${i + 1}/${count})...`, { module: 'Scroller' });

                // Создаем промис для задержки
                const delayPromise = new Promise(resolve => setTimeout(resolve, delayMs));

                try {
                    // Используем Promise.race между задержкой и сигналом остановки.
                    // context.abortSignal() должен возвращать промис, который:
                    // - Разрешается успешно, если остановки нет (ЭТО НЕВЕРНО ДЛЯ RACE!)
                    // - Отклоняется с ошибкой, если сработал сигнал остановки.
                    //
                    // ПРАВИЛЬНАЯ логика: мы хотим ждать задержку, НО прерваться, если поступил сигнал.
                    // Значит, abortSignal должен возвращать промис, который ЖДЕТ сигнала (не разрешается сам).
                    // Но наша текущая реализация resolve() его. Это проблема.
                    //
                    // ПЕРЕДЕЛАЕМ ЛОГИКУ:
                    // 1. Создадим отдельный AbortController для этой паузы.
                    // 2. Будем ждать либо таймаут, либо сигнал остановки напрямую.

                    // Создаем новый контроллер для управления этой паузой
                    const pauseController = new AbortController();
                    const abortPromise = new Promise((_, reject) => {
                        // Слушаем сигнал остановки от основного контроллера сценария
                        context.controller.signal.addEventListener('abort', () => {
                            reject(new Error('Сценарий остановлен пользователем.'));
                        }, { once: true, signal: pauseController.signal }); // Привязываем к нашему pauseController, чтобы можно было отменить слушатель
                    });

                    // Гонка между таймаутом и сигналом остановки
                    await Promise.race([
                        new Promise(resolve => setTimeout(resolve, delayMs)), // Таймаут
                        abortPromise // Сигнал остановки
                    ]);

                    // Если дошли до этой точки, значит либо прошло время, либо сценарий остановлен.
                    // Проверка на остановку уже включена в abortPromise.

                } catch (err) {
                    // Если прервано по сигналу
                    log(`⏹️ Скроллинг остановлен пользователем во время ожидания (${i + 1}/${count}).`, { module: 'Scroller', level: 'warn' });
                    throw err; // Пробрасываем исключение дальше
                }
                // Если не было исключения, цикл продолжится
            }
        }

        // После завершения всех скроллов можно оценить количество карточек
        try {
            const countResponse = await chrome.tabs.sendMessage(context.tabId, {
                action: "getEstimatedCardCount"
            });
            const cardCount = countResponse?.cardCount || 0;
            log(`✅ Скроллинг завершён. Обработано примерно ${cardCount} карточек.`, { module: 'Scroller' });
        } catch (countErr) {
            console.warn("[Core Scroller] Не удалось получить количество карточек после скроллинга:", countErr);
            log(`✅ Скроллинг завершён.`, { module: 'Scroller' });
        }

    } catch (err) {
        console.error("[Scroller] Поймано исключение в scrollPageNTimes:", err); // <-- Лог ошибок

        if (err.message === 'Сценарий остановлен пользователем.') {
            log(`⏹️ Скроллинг остановлен пользователем.`, { module: 'Scroller', level: 'warn' });
        } else {
            log(`❌ Ошибка при выполнении скроллинга: ${err.message}`, { module: 'Scroller', level: 'error' });
        }
        throw err; // Перебрасываем ошибку для обработки в сценарии
    }
}

=== END FILE: D:\разработка\youtube-parser-os\core\utils\scroller.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\core\utils\video-selector.js ===

// core/utils/video-selector.js

import { getUnavailableVideoIds } from './blacklist.js';

/**
 * @typedef {Object} VideoData
 * @property {string} videoId - Уникальный идентификатор видео.
 * @property {string} title - Название видео.
 * @property {string} channelName - Название канала.
 * @property {string} sourceVideoId - ID видео, с которого был совершен переход.
 * @property {string} views - Количество просмотров.
 * @property {string} thumbnailUrl - URL миниатюры.
 * ... другие поля
 */

/**
 * Выбирает следующее видео для перехода по алгоритму "минимизация количества видео на канал".
 *
 * @param {Object} dependencies - Зависимости для работы функции.
 * @param {Set<string>} dependencies.visitedSourceVideoIds - Множество ID видео, на которые мы уже заходили (sourceVideoId).
 * @param {Map<string, number>} dependencies.channelVideoCounts - Словарь: канал -> количество видео из этого канала.
 * @param {Map<string, Set<string>>} dependencies.channelToVideoIds - Словарь: канал -> множество ID видео этого канала.
 * @param {string} currentVideoId - ID текущего видео (на котором мы сейчас находимся и которое только что спарсили).
 * @param {'current_recommendations' | 'all_videos'} mode - Режим выбора.
 * @param {Array<VideoData>} scrapedData - Массив видео, полученных на текущем шаге (для 'current_recommendations').
 * @param {Object} context - Контекст для логирования.
 * @param {Function} context.log - Функция логирования.
 * @returns {Promise<string|null>} ID следующего видео (videoId) или null, если не удалось выбрать.
 */
export async function selectNextVideo(
    { visitedSourceVideoIds, channelVideoCounts, channelToVideoIds },
    currentVideoId,
    mode,
    scrapedData = [],
    context
) {
    const { log } = context;

    log(`🔍 Начинаем выбор следующего видео. Запрошенный режим: ${mode}, Текущее видео ID: ${currentVideoId}`, { module: 'VideoSelector' });
    log(`👣 Размер списка посещенных sourceVideoId: ${visitedSourceVideoIds.size}`, { module: 'VideoSelector' });
    log(`📈 Размер индекса каналов: ${channelVideoCounts.size}`, { module: 'VideoSelector' });
    log(`🎞️ Размер индекса видео по каналам: ${channelToVideoIds.size}`, { module: 'VideoSelector' });

    try {
        // --- 0. Получаем черный список недоступных видео ---
        const unavailableVideoIdsSet = await getUnavailableVideoIds();
        log(`🔒 Получен черный список недоступных видео. Размер: ${unavailableVideoIdsSet.size}`, { module: 'VideoSelector' });

        // --- 1. Определяем кандидатов в зависимости от исходного режима ---
        let candidateVideos = [];
        let candidateSource = '';
        let effectiveMode = mode; // Изначально используем запрошенный режим

        // --- ВАЖНО: Проверка на количество уникальных каналов ---
        // Определяем кандидатов для проверки количества каналов
        let channelsToCheckForOverride = new Set();
        if (effectiveMode === 'current_recommendations') {
            channelsToCheckForOverride = new Set(scrapedData.map(v => v.channelName || 'Неизвестный канал'));
        } else if (effectiveMode === 'all_videos') {
            // Для 'all_videos' сначала определим топ каналы, как в основном алгоритме
            const allChannels = Array.from(channelVideoCounts.keys());
            const sortedChannels = allChannels
                .map(channel => ({ name: channel, count: channelVideoCounts.get(channel) || 0 }))
                .sort((a, b) => a.count - b.count);
            const top10ChannelsInitial = sortedChannels.slice(0, 10);
            channelsToCheckForOverride = new Set(top10ChannelsInitial.map(c => c.name));
        }

        // Проверка условия: если уникальных каналов меньше 2, переопределяем режим
        if (channelsToCheckForOverride.size < 2) {
            const oldMode = effectiveMode;
            effectiveMode = 'all_videos'; // Принудительно меняем режим
            log(`⚠️ В исходных кандидатах для режима '${oldMode}' найдено менее 2 уникальных каналов (${channelsToCheckForOverride.size}). Режим выбора изменен на '${effectiveMode}'.`, { module: 'VideoSelector', level: 'warn' });
        } else {
            log(`✅ В исходных кандидатах для режима '${effectiveMode}' найдено ${channelsToCheckForOverride.size} уникальных каналов. Продолжаем с этим режимом.`, { module: 'VideoSelector' });
        }
        // --- Конец проверки на количество уникальных каналов ---

        // --- 2. Основная логика выбора кандидатов с учетом эффективного режима ---
        if (effectiveMode === 'current_recommendations') {
            // --- РЕЖИМ: Анализ видео из последней подборки ---
            candidateSource = 'последняя подборка (scrapedData)';
            log(`🎞️ Режим 'current_recommendations': используем ${scrapedData.length} видео из последней подборки.`, { module: 'VideoSelector' });
            candidateVideos = [...scrapedData]; // Копируем массив

        } else if (effectiveMode === 'all_videos') {
            // --- РЕЖИМ: Анализ всех видео ---
            candidateSource = 'все видео (channelToVideoIds)';
            log(`🌐 Режим 'all_videos': используем все видео из индексов.`, { module: 'VideoSelector' });

            // 1. Получаем список уникальных каналов из channelVideoCounts
            const allChannels = Array.from(channelVideoCounts.keys());
            log(`📈 Найдено ${allChannels.length} уникальных каналов во всех данных.`, { module: 'VideoSelector' });

            // 2. Сортируем каналы по возрастанию количества видео
            const sortedChannels = allChannels
                .map(channel => ({ name: channel, count: channelVideoCounts.get(channel) || 0 }))
                .sort((a, b) => a.count - b.count);

            log(`📊 Каналы отсортированы по возрастанию количества видео (первые 10):`, { module: 'VideoSelector' });
            sortedChannels.slice(0, 10).forEach((c, i) => {
                log(`   ${i + 1}. ${c.name} (${c.count})`, { module: 'VideoSelector' });
            });

            // 3. Берем первые 10 каналов
            const top10Channels = sortedChannels.slice(0, 10);

            // 4. Собираем все videoId из этих каналов
            const videoIdsFromTopChannels = new Set();
            for (const { name: channelName } of top10Channels) {
                const videoIdsInChannel = channelToVideoIds.get(channelName);
                if (videoIdsInChannel) {
                    for (const id of videoIdsInChannel) {
                        videoIdsFromTopChannels.add(id);
                    }
                }
            }
            log(`🎞️ Собрано ${videoIdsFromTopChannels.size} уникальных videoId из топ-10 каналов.`, { module: 'VideoSelector' });

            // 5. Создаем "виртуальные" объекты VideoData для кандидатов
            candidateVideos = Array.from(videoIdsFromTopChannels).map(videoId => {
                // Найти канал для этого videoId (неэффективно, но для MVP сойдет)
                let channelName = 'Неизвестный канал из Top10';
                for (const { name: chName } of top10Channels) {
                    const videoIds = channelToVideoIds.get(chName);
                    if (videoIds && videoIds.has(videoId)) {
                        channelName = chName;
                        break;
                    }
                }
                return { videoId, channelName };
            });

        } else {
            log(`❓ Неизвестный эффективный режим выбора: ${effectiveMode}. Используем scrapedData как кандидатов.`, { module: 'VideoSelector', level: 'warn' });
            candidateVideos = [...scrapedData];
            candidateSource = 'scrapedData (по умолчанию для неизвестного режима)';
            effectiveMode = 'current_recommendations'; // Уточняем эффективный режим для логики ниже
        }

        if (candidateVideos.length === 0) {
            log(`📉 Нет кандидатов для выбора из источника '${candidateSource}'.`, { module: 'VideoSelector', level: 'warn' });
            return null;
        }

        log(`✅ Получено ${candidateVideos.length} кандидатов для выбора из '${candidateSource}' (эффективный режим: ${effectiveMode}).`, { module: 'VideoSelector' });

        // --- 3. Фильтрация кандидатов ---
        const filteredCandidates = candidateVideos.filter(v =>
            v.videoId &&
            v.videoId !== currentVideoId &&
            !unavailableVideoIdsSet.has(v.videoId)
        );

        log(`🧹 После фильтрации (не текущее, не недоступное): ${filteredCandidates.length} видео.`, { module: 'VideoSelector' });
        if (filteredCandidates.length === 0) {
            log(`📉 Нет кандидатов после фильтрации.`, { module: 'VideoSelector', level: 'warn' });
            return null;
        }

        // --- 4. Сортировка каналов кандидатов по глобальному количеству видео ---
        const candidateChannelsMap = new Map();
        for (const video of filteredCandidates) {
            const channel = video.channelName || 'Неизвестный канал';
            if (!candidateChannelsMap.has(channel)) {
                candidateChannelsMap.set(channel, { count: 0, videos: [] });
            }
            const globalCount = channelVideoCounts.get(channel) || 0;
            candidateChannelsMap.get(channel).count = globalCount;
            candidateChannelsMap.get(channel).videos.push(video);
        }

        const sortedCandidateChannels = Array.from(candidateChannelsMap.entries())
            .map(([name, data]) => ({ name, ...data }))
            .sort((a, b) => a.count - b.count);

        log(`📊 Каналы кандидатов отсортированы по глобальному количеству видео (первые 10):`, { module: 'VideoSelector' });
        sortedCandidateChannels.slice(0, 10).forEach((c, i) => {
            log(`   ${i + 1}. ${c.name} (${c.count})`, { module: 'VideoSelector' });
        });

        // --- 5. Поиск подходящего видео ---
        log(`🔍 Начинаем поиск подходящего видео по топ-каналам...`, { module: 'VideoSelector' });

        for (let i = 0; i < Math.min(10, sortedCandidateChannels.length); i++) {
            const channelData = sortedCandidateChannels[i];
            const channelName = channelData.name;
            const channelVideos = channelData.videos;
            log(`🔍 Проверяем канал: ${channelName} (глобальное количество: ${channelData.count})`, { module: 'VideoSelector' });

            for (const video of channelVideos) {
                if (!visitedSourceVideoIds.has(video.videoId)) {
                    log(`🎯 НАЙДЕНО подходящее видео: ${video.videoId} из канала ${channelName}`, { module: 'VideoSelector', level: 'success' });
                    return video.videoId;
                } else {
                    log(`⏭️ Пропущено видео ${video.videoId} (уже было sourceVideoId)`, { module: 'VideoSelector' });
                }
            }
        }

        // --- 6. Fallback: случайное видео из отфильтрованных кандидатов ---
        log(`🔄 Поиск по топ-каналам не дал результата. Пробуем случайное видео из отфильтрованных кандидатов...`, { module: 'VideoSelector', level: 'warn' });
        if (filteredCandidates.length > 0) {
            const randomIndex = Math.floor(Math.random() * filteredCandidates.length);
            const randomVideo = filteredCandidates[randomIndex];
            log(`🎲 Fallback выбрал случайное видео: ${randomVideo.videoId}`, { module: 'VideoSelector', level: 'warn' });
            return randomVideo.videoId;
        }

        log(`❌ Не удалось выбрать следующее видео.`, { module: 'VideoSelector', level: 'error' });
        return null;

    } catch (err) {
        log(`❌ Ошибка в процессе выбора следующего видео: ${err.message}`, { module: 'VideoSelector', level: 'error' });
        console.error("[VideoSelector] Stack trace:", err);
        return null;
    }
}

=== END FILE: D:\разработка\youtube-parser-os\core\utils\video-selector.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\popup.css ===

/* === popup/popup.css === */

/* --- 1. Переменные темы --- */
:root {
    --primary: #4338ca;
    --primary-hover: #3730a3;
    --success: #16a34a;
    --success-hover: #15803d;
    --warning: #ca8a04;
    --warning-hover: #a16207;
    --danger: #dc2626;
    --danger-hover: #b91c1c;
    --info: #0284c7;
    --info-hover: #0369a1;
    --secondary: #64748b;
    --secondary-hover: #475569;
    --bg: #ffffff;
    --card: #f9fafb;
    --text: #111827;
    --border: #e5e7eb;
    --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

/* --- 2. Базовые стили --- */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--bg);
    color: var(--text);
    padding: 16px;
    /* Фиксируем размер области видимости popup */
    width: 800px;
    height: 720px;
    /* Разрешаем скролл внутри body, если содержимое больше */
    overflow: auto;
    /* Убираем скрытие полос прокрутки, если они появятся */
    /* overflow: hidden; УДАЛИТЬ */
}

/* --- 3. Макет приложения --- */
.app-container {
    display: flex;
    flex-direction: column;
    gap: 16px;
    /* Указываем желаемую высоту содержимого */
    /* height: 100%; УДАЛИТЬ или изменить */
    height: calc(720px - 32px);
    /* 720px (body height) - 32px (padding body 16*2) = 688px */
    /* ИЛИ, если хочешь конкретно 800px для содержимого: */
    /* height: 800px; */
    /* Установит высоту контента в 800px, независимо от body */
    /* Если height будет больше, чем высота body (720px - 32px = 688px), появится скролл у body */

    /* Предотвращаем рост больше заданной высоты, если содержимое меньше */
    /* min-height: 100%; НЕ НУЖНО, если height фиксирован */
    /* Разрешаем скролл внутри app-container, если его содержимое (секции) больше его высоты */
    /* overflow: hidden; УДАЛИТЬ */
    overflow: visible;
    /* Или auto, если хочешь скролл внутри app-container при необходимости */
}

.app-title {
    font-size: 20px;
    font-weight: 600;
    color: var(--primary);
    margin-bottom: 16px;
    text-align: center;
}

/* --- 4. Секции (Sections) --- */
.section {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 16px;
    box-shadow: var(--shadow);
    flex-shrink: 0;
    /* 👇 ВАЖНО: Возвращаем overflow: hidden для .section */
    overflow: hidden;
    /* Это заставит flex-потомков (#logSection.content, #tableSection.content) 
       управлять своим переполнением, если они используют flex и maxHeight/minHeight */
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

#logSection .section-header {
    margin-bottom: 8px;
}

.section-title {
    font-size: 16px;
    font-weight: 600;
    color: var(--text);
}

/* --- 5. Секция настроек --- */
.settings-section.collapsed #settingsContent {
    display: none;
}

.setting-item {
    margin-bottom: 16px;
}

.setting-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: var(--text);
}

.radio-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.radio-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 6px;
}

.radio-label:hover {
    background: var(--border);
}

.input-field {
    width: 100%;
    max-width: 200px;
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 14px;
}

.import-textarea {
    width: 100%;
    min-height: 120px;
    padding: 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-family: monospace;
    font-size: 13px;
    resize: vertical;
    margin-bottom: 12px;
}

.toggle-btn {
    background: none;
    border: none;
    font-size: 16px;
    cursor: pointer;
    color: var(--secondary);
    padding: 4px 8px;
    border-radius: 6px;
}

.toggle-btn:hover {
    background: var(--border);
}

/* --- 6. Группы кнопок --- */
.button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
}

.btn {
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.btn:hover {
    transform: translateY(-1px);
    box-shadow: var(--shadow);
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

/* --- 7. Цвета кнопок --- */
.btn-primary {
    background: var(--primary);
    color: white;
}

.btn-primary:hover {
    background: var(--primary-hover);
}

.btn-success {
    background: var(--success);
    color: white;
}

.btn-success:hover {
    background: var(--success-hover);
}

.btn-warning {
    background: var(--warning);
    color: white;
}

.btn-warning:hover {
    background: var(--warning-hover);
}

.btn-danger {
    background: var(--danger);
    color: white;
}

.btn-danger:hover {
    background: var(--danger-hover);
}

.btn-info {
    background: var(--info);
    color: white;
}

.btn-info:hover {
    background: var(--info-hover);
}

.btn-secondary {
    background: var(--secondary);
    color: white;
}

.btn-secondary:hover {
    background: var(--secondary-hover);
}

/* --- 8. Секция журнала --- */
#logSection {
    flex: 2;
    min-height: 250px;
    /* Уже установлено */
    display: flex;
    flex-direction: column;
    overflow: hidden;
    /* Остается на .section */
}

.log-container {
    padding: 12px;
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
    background: white;
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 12px;
    line-height: 1.5;
}

.log-entry {
    padding: 6px 0;
    border-bottom: 1px solid var(--border);
    font-family: monospace;
}

.log-entry:last-child {
    border-bottom: none;
}

/* Цвета уровней логов */
.log-level-info {
    color: var(--text);
}

.log-level-success {
    color: var(--success);
    font-weight: 500;
}

.log-level-warn {
    color: var(--warning);
}

.log-level-error {
    color: var(--danger);
    font-weight: 500;
}

/* Placeholder для журнала */
.log-placeholder {
    color: var(--secondary);
    font-style: italic;
    text-align: center;
    padding: 20px 0;
}

/* --- 9. Секция таблицы --- */
#tableSection {
    flex: 3;
    min-height: 250px;
    /* Уже установлено */
    display: flex;
    flex-direction: column;
    overflow: hidden;
    /* Остается на .section */
}

#tableSection .section-header {
    margin-bottom: 8px;
}

/* --- 10. Таблица данных --- */
.table-container {
    flex: 1;
    overflow: auto;
    min-height: 0;
    border: 1px solid var(--border);
    border-radius: 8px;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    height: 100%;
}

.data-table th,
.data-table td {
    padding: 8px;
    text-align: left;
    border: 1px solid var(--border);
}

.data-table th {
    background-color: var(--card);
    font-weight: 600;
    position: sticky;
    top: 0;
    z-index: 1;
}

.data-table tr:nth-child(even) {
    background-color: #fafafa;
}

/* Placeholder для таблицы */
.table-placeholder td {
    text-align: center;
    color: var(--secondary);
    font-style: italic;
    padding: 40px 20px;
}

.data-table img {
    width: 60px;
    height: 34px;
    object-fit: cover;
    border-radius: 4px;
}

/* --- 11. Скроллбары --- */
.log-container::-webkit-scrollbar,
.table-container::-webkit-scrollbar {
    width: 6px;
}

.log-container::-webkit-scrollbar-thumb,
.table-container::-webkit-scrollbar-thumb {
    background-color: var(--border);
    border-radius: 3px;
}

=== END FILE: D:\разработка\youtube-parser-os\popup\popup.css ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\popup.html ===

<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Рекомендации Парсер</title>
    <link rel="stylesheet" href="popup.css">
</head>

<body>
    <div class="app-container">
        <header class="app-header">
            <h1 class="app-title">📹 YouTube Рекомендации Парсер</h1>
        </header>

        <!-- Настройки (Collapsible) -->
        <section id="settingsSection" class="section settings-section">
            <div class="section-header">
                <h2 class="section-title">⚙️ Настройки</h2>
                <button id="toggleSettingsBtn" class="toggle-btn">▲</button>
            </div>
            <div id="settingsContent" class="section-content">
                <!-- Алгоритм выбора -->
                <div class="setting-item">
                    <label class="setting-label">Алгоритм выбора следующего видео:</label>
                    <div class="radio-group">
                        <!-- Изменяем текст и value -->
                        <label class="radio-label">
                            <input type="radio" name="selectionMode" value="all_videos" checked>
                            Анализ всех видео
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="selectionMode" value="current_recommendations">
                            Анализ видео из последней подборки
                        </label>
                    </div>
                </div>

                <!-- Количество итераций -->
                <div class="setting-item">
                    <label class="setting-label" for="iterationsInput">Количество итераций:</label>
                    <input type="number" id="iterationsInput" class="input-field" value="10" min="1" max="1000">
                </div>

                <!-- Импорт данных -->
                <div class="setting-item">
                    <label class="setting-label">Импорт данных (CSV/TSV):</label>
                    <textarea id="importTextarea" class="import-textarea"
                        placeholder="Вставьте данные... Название,ID,Просмотры,Канал,Исходное видео,Миниатюра"></textarea>
                    <div class="button-group">
                        <button id="importDataBtn" class="btn btn-primary">📂 Загрузить данные</button>
                        <button id="clearImportedBtn" class="btn btn-secondary">🗑️ Очистить импортированные</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Управление -->
        <section id="controlSection" class="section control-section">
            <div class="section-header">
                <h2 class="section-title">🎛️ Управление</h2>
            </div>
            <div class="control-group">
                <!-- Выпадающий список сценариев -->
                <div class="setting-item">
                    <label class="setting-label" for="scenarioSelector">Выберите сценарий:</label>
                    <select id="scenarioSelector" class="input-field">
                        <option value="parse-recommendation">Парсинг рекомендаций</option>
                        <option value="test-countdown">Тестовый сценарий: Обратный отсчет</option>
                        <!-- В будущем можно добавить больше опций -->
                    </select>
                </div>

                <!-- Кнопки управления -->
                <div class="button-group">
                    <!-- Изменяем ID и текст кнопки запуска -->
                    <button id="runScenarioBtn" class="btn btn-success">▶️ Запустить сценарий</button>
                    <!-- Кнопка остановки, как и раньше -->
                    <button id="stopBtn" class="btn btn-warning" disabled>⏹️ Остановить</button>
                    <button id="copyTableBtn" class="btn btn-info">📋 Копировать таблицу</button>
                    <button id="clearTableBtn" class="btn btn-danger">🗑️ Очистить таблицу</button>
                    <button id="clearLogBtn" class="btn btn-secondary">🧹 Очистить журнал</button>
                    <button id="resetIndicesBtn" class="btn btn-secondary">🔄 Сбросить индексы</button>
                    <button id="dumpIndicesBtn" class="btn btn-secondary">🔍 Dump Indices to Console</button>
                </div>
            </div>
        </section>

        <!-- Журнал событий -->
        <section id="logSection" class="section log-section">
            <div class="section-header">
                <h2 class="section-title">📋 Журнал событий</h2>
            </div>
            <div id="logContainer" class="log-container">
                <!-- Логи будут вставляться сюда -->
                <div class="log-placeholder">Журнал пуст</div>
            </div>
        </section>

        <!-- Таблица данных -->
        <section id="tableSection" class="section table-section">
            <div class="section-header">
                <h2 class="section-title">📊 Спарсенные данные</h2>
            </div>
            <div class="table-container">
                <table id="dataTable" class="data-table">
                    <thead>
                        <tr>
                            <th>Название</th>
                            <th>ID</th>
                            <th>Просмотры</th>
                            <th>Канал</th>
                            <th>Исходное видео</th>
                            <th>Миниатюра</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Данные будут вставляться сюда -->
                        <tr class="table-placeholder">
                            <td colspan="6">Таблица пуста</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
    </div>

    <script type="module" src="./popup.js"></script>
</body>

</html>

=== END FILE: D:\разработка\youtube-parser-os\popup\popup.html ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\popup.js ===


// popup/popup.js
import { SettingsSection } from './components/SettingsSection.js';
import { ControlSection } from './components/ControlSection.js';
import { LogSection } from './components/LogSection.js';
import { TableSection } from './components/TableSection.js';

class PopupApp {
    constructor() {
        this.initElements();
        this.initComponents(); // Инициализируем компоненты и загружаем начальные данные
        this.bindEvents(); // Привязываем события popup-контроллера
        this.loadState(); // Загружаем сохранённое состояние UI
        this.updateScenarioControlButtons(false);
        this.checkScenarioStatusOnLoad();
        this.isScenarioLaunchInProgress = false;
    }

    initElements() {
        // Инициализируем ссылки на DOM элементы, принадлежащие popup напрямую
        this.settingsSection = document.getElementById('settingsSection');
        this.settingsContent = document.getElementById('settingsContent');
        this.toggleSettingsBtn = document.getElementById('toggleSettingsBtn');

        this.selectionModeRadios = document.querySelectorAll('input[name="selectionMode"]');
        this.iterationsInput = document.getElementById('iterationsInput');
        this.importTextarea = document.getElementById('importTextarea');
        this.importDataBtn = document.getElementById('importDataBtn');
        this.clearImportedBtn = document.getElementById('clearImportedBtn');

        this.runScenarioBtn = document.getElementById('runScenarioBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.copyTableBtn = document.getElementById('copyTableBtn');
        this.clearTableBtn = document.getElementById('clearTableBtn');
        this.clearLogBtn = document.getElementById('clearLogBtn');

        // Элемент для нового функционала

        this.scenarioSelector = document.getElementById('scenarioSelector');

        document.addEventListener('importData', (e) => {
            this.handleImportData(e.detail); // Передаём detail как аргумент
        });
    }

    initComponents() {
        // Создаём экземпляры компонентов. Они сами привяжут свои обработчики и DOM.
        this.settings = new SettingsSection();
        this.control = new ControlSection();
        this.logs = new LogSection();
        this.table = new TableSection();

        // Инициируем загрузку начальных данных для компонентов
        // Это заменяет старые updateLogs и updateTable
        this.logs.loadInitialLogs();
        this.table.loadInitialData();
    }

    bindEvents() {
        // --- Обработчики UI popup-а ---
        this.selectionModeRadios.forEach(radio => {
            radio.addEventListener('change', () => this.saveSettings());
        });
        this.iterationsInput.addEventListener('change', () => this.saveSettings());
        this.importDataBtn.addEventListener('click', () => this.handleImport());
        this.clearImportedBtn.addEventListener('click', () => this.handleClearImported());

        this.runScenarioBtn.addEventListener('click', () => this.handleRunScenario());
        this.stopBtn.addEventListener('click', () => this.handleStop());
        this.copyTableBtn.addEventListener('click', () => this.handleCopyTable());
        this.clearTableBtn.addEventListener('click', () => this.handleClearTable());
        this.clearLogBtn.addEventListener('click', () => this.handleClearLog());

        this.runScenarioBtn.addEventListener('click', () => this.handleRunScenario());

        // --- Слушатель сообщений от background ---
        this.addMessageListener();
    }

    saveSettings() {
        // Определяем состояние для сохранения
        const isSettingsCollapsed = this.settingsSection.classList.contains('collapsed');

        const state = {
            isSettingsCollapsed: isSettingsCollapsed,
            selectionMode: document.querySelector('input[name="selectionMode"]:checked')?.value || 'smart',
            iterations: this.iterationsInput.value,
        };


        try {
            localStorage.setItem('popupSettings', JSON.stringify(state));
        } catch (e) {
            console.error("saveSettings: Ошибка при сохранении в localStorage:", e);
        }
    }

    loadState() {

        const savedStateJson = localStorage.getItem('popupSettings');
        if (savedStateJson) {
            try {
                const state = JSON.parse(savedStateJson);
                if (state.isSettingsCollapsed === true) {
                    this.settingsSection.classList.add('collapsed');
                    this.toggleSettingsBtn.textContent = '🔽';
                } else {
                    this.settingsSection.classList.remove('collapsed');
                    this.toggleSettingsBtn.textContent = '▲';
                }

                // Применяем другие настройки (если есть)
                if (state.selectionMode) {
                    const radio = document.querySelector(`input[name="selectionMode"][value="${state.selectionMode}"]`);
                    if (radio) {
                        radio.checked = true;
                    }
                }

                if (state.iterations) {
                    this.iterationsInput.value = state.iterations;
                }
            } catch (e) {
                console.error("loadState: Ошибка при парсинге сохранённого состояния:", e);
                // В случае ошибки парсинга, используем значения по умолчанию
                // и пересохраняем их
            }
        } else {
            this.settingsSection.classList.remove('collapsed'); // По умолчанию развернуто
            this.toggleSettingsBtn.textContent = '▲';
            // Другие значения по умолчанию уже заданы в HTML
        }
    }

    // --- Message Listener ---
    addMessageListener() {
        this.messageListener = (request, sender, sendResponse) => {
            if (request.type === 'scenarioStatus') {
                console.log("PopupApp: Received scenarioStatus message", request);
                if (request.status === 'started') {
                    this.updateScenarioControlButtons(true);
                } else if (request.status === 'stopped' || request.status === 'finished') {
                    console.log("PopupApp: Updating buttons to STOPPED state based on scenarioStatus"); // <-- Лог
                    this.updateScenarioControlButtons(false);
                }
                // Логируем сообщение от сценария, если оно есть
                if (request.message) {
                    document.dispatchEvent(new CustomEvent('log', { detail: { message: request.message, level: request.level || 'info' } }));
                }
                return;
            }

            if (request.type === 'dataUpdated') {
                this.table.loadInitialData();
            }

            if (request.type === 'dataCleared') {
                document.dispatchEvent(new CustomEvent('clearTable'));
            }

            if (request.type === 'newLog' && request.log) {
                document.dispatchEvent(new CustomEvent('log', { detail: request.log }));
            }

            if (request.type === 'logsCleared') {
                document.dispatchEvent(new CustomEvent('clearLog'));
            }

            if (request.type === 'dataCleared') {
                document.dispatchEvent(new CustomEvent('clearTable'));
            }

            // TODO: Добавить обработчики для других сообщений
            // if (request.type === 'analysisStatus') { ... }
            // if (request.type === 'dataUpdated') { 
            //    document.dispatchEvent(new CustomEvent('updateTable', { detail: newDataArray }));
            // }
        };

        chrome.runtime.onMessage.addListener(this.messageListener);
    }

    // --- Button Handlers (имитация / заглушки) ---
    // Эти обработчики теперь используют CustomEvent для взаимодействия с компонентами
    // или напрямую вызывают chrome.runtime.sendMessage

    handleImport() {
        const text = this.importTextarea.value.trim();
        if (!text) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: '❌ Нет данных для импорта', level: 'error' } }));
            return;
        }
        document.dispatchEvent(new CustomEvent('log', { detail: { message: `✅ Импорт данных (имитация): ${text.split('\n').length - 1} строк`, level: 'success' } }));
        this.importTextarea.value = '';
        // В реальном сценарии здесь будет sendMessage для импорта в background
        // и затем событие обновления таблицы
        setTimeout(() => {
            this.table.loadInitialData(); // Имитация обновления таблицы
        }, 500);
    }

    handleClearImported() {
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Импортированные данные очищены (имитация)', level: 'success' } }));
        // В реальном сценарии здесь будет sendMessage для очистки в background
    }

    async handleRunScenario() {
        if (this.isScenarioLaunchInProgress) {
            console.warn("[PopupApp] Запуск сценария уже выполняется, игнорируем клик.");
            return;
        }
        this.isScenarioLaunchInProgress = true; // <-- Установить флаг
        // 1. Получаем ID выбранного сценария
        const selectedScenarioId = this.scenarioSelector.value;
        if (!selectedScenarioId) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: '❌ Не выбран сценарий для запуска', level: 'error' } }));
            return;
        }

        // 2. Получаем параметры из UI
        const iterations = parseInt(this.iterationsInput.value) || 10;
        const mode = document.querySelector('input[name="selectionMode"]:checked')?.value || 'all_videos';

        // 3. Логируем начало
        const scenarioName = this.scenarioSelector.options[this.scenarioSelector.selectedIndex].text;
        document.dispatchEvent(new CustomEvent('log', { detail: { message: `📤 Запуск сценария "${scenarioName}": ${iterations} итераций, режим: ${mode}`, level: 'info' } }));

        try {
            // 4. Отправляем сообщение в background с параметрами
            const response = await chrome.runtime.sendMessage({
                action: "runScenario",
                scenarioId: selectedScenarioId,
                params: {
                    iterations,
                    mode,
                    // Параметры для скроллинга (можно сделать настройками позже)
                    count: 3,
                    delayMs: 1500,
                    step: 1000
                }
            });

            if (response && response.status === "started") {
                console.log("[PopupApp] Сценарий успешно запущен в background, обновляем состояние кнопок.");
                // 5. Обновляем состояние кнопок
                this.updateScenarioControlButtons(true);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `✅ Сценарий запущен. ID: ${response.instanceId}`, level: 'success' } }));
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка при запуске';
                console.error("[PopupApp] Ошибка запуска сценария:", errorMsg);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка запуска сценария: ${errorMsg}`, level: 'error' } }));
                // Возвращаем кнопки в исходное состояние в случае ошибки
                this.updateScenarioControlButtons(false);
            }

        } catch (err) {
            console.error("[PopupApp] Исключение при запуске сценария:", err);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка связи при запуске сценария: ${err.message}`, level: 'error' } }));
            // Возвращаем кнопки в исходное состояние в случае ошибки
            this.isScenarioLaunchInProgress = false;
            this.updateScenarioControlButtons(false);
        } finally {
            // Сбросить флаг в любом случае, после попытки запуска
            console.log("[PopupApp] Finally блок handleRunScenario: сброс флага isScenarioLaunchInProgress.");
            this.isScenarioLaunchInProgress = false; // <-- Сбросить флаг
            this.updateScenarioControlButtons(false);
        }
    }

    async handleStop() {
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '📤 Отправка команды на остановку всех сценариев...', level: 'info' } }));

        try {
            // Отправляем сообщение в background для остановки всех сценариев
            const response = await chrome.runtime.sendMessage({
                action: "stopAllScenarios"
            });

            if (response && response.status === "success") {
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `✅ ${response.message}`, level: 'warn' } }));
                // Обновляем состояние кнопок
                this.updateScenarioControlButtons(false);
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка при остановке';
                console.error("[PopupApp] Ошибка остановки сценариев:", errorMsg);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка остановки сценариев: ${errorMsg}`, level: 'error' } }));
                // Оставляем кнопки в состоянии "запущено", так как остановка не удалась
            }
        } catch (err) {
            console.error("[PopupApp] Исключение при остановке сценариев:", err);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка связи при остановке сценариев: ${err.message}`, level: 'error' } }));
            // Оставляем кнопки в состоянии "запущено", так как остановка не удалась
        }
    }

    async handleCopyTable() {
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '📤 Подготовка таблицы для копирования...', level: 'info' } }));
        try {
            const response = await chrome.runtime.sendMessage({ action: "copyTableData" });
            if (response.status === "success") {
                await navigator.clipboard.writeText(response.data);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Таблица скопирована в буфер обмена', level: 'success' } }));
            } else {
                throw new Error(response.message);
            }
        } catch (err) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка копирования таблицы: ${err.message}`, level: 'error' } }));
        }
    }

    async handleClearTable() {
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '📤 Отправка команды на очистку таблицы...', level: 'info' } }));
        try {
            const response = await chrome.runtime.sendMessage({ action: "clearTableData" });
            if (response.status === "success") {
                document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Таблица очищена', level: 'success' } }));
                // Сообщаем TableSection об очистке
                document.dispatchEvent(new CustomEvent('clearTable'));
            } else {
                throw new Error(response.message);
            }
        } catch (err) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка очистки таблицы: ${err.message}`, level: 'error' } }));
        }
    }

    async handleClearLog() {
        // В реальном сценарии popup отправляет сообщение в background для очистки
        // и background потом прислает 'logsCleared' или popup сам обновит UI
        try {
            await chrome.storage.local.remove(['appLogs']);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Журнал очищен', level: 'success' } }));
            // Сообщаем компоненту журнала об очистке
            document.dispatchEvent(new CustomEvent('clearLog'));
        } catch (err) {
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка очистки журнала: ${err.message}`, level: 'error' } }));
        }
    }

    async handleImportData(eventDetail) {
        const dataToImport = eventDetail && eventDetail.data;

        if (!dataToImport || !Array.isArray(dataToImport)) {
            console.error("[PopupApp] handleImportData: данные отсутствуют или не являются массивом", dataToImport);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: '❌ Ошибка: Некорректные данные для импорта', level: 'error' } }));
            return;
        }

        document.dispatchEvent(new CustomEvent('log', { detail: { message: `📤 Отправка ${dataToImport.length} записей для импорта...`, level: 'info' } }));

        try {
            // Отправляем данные в background для сохранения
            const response = await chrome.runtime.sendMessage({
                action: "importTableData", // Новое сообщение для обработки импорта
                data: dataToImport // Отправляем массив напрямую
            });

            if (response && response.status === "success") {
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `✅ ${response.count} записей успешно импортированы`, level: 'success' } }));
                // Принудительно обновляем таблицу в popup
                this.table.loadInitialData();
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка';
                console.error("[PopupApp] Ошибка импорта в background:", errorMsg);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка импорта: ${errorMsg}`, level: 'error' } }));
            }
        } catch (err) {
            console.error("[PopupApp] Ошибка отправки данных в background:", err);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка связи с background: ${err.message}`, level: 'error' } }));
        }
    }

    /**
     * Обновляет состояние кнопок управления сценариями.
     * @param {boolean} isRunning - Запущен ли сейчас какой-либо сценарий.
     */
    updateScenarioControlButtons(isRunning) {
        if (this.runScenarioBtn && this.stopBtn) {
            this.runScenarioBtn.disabled = isRunning;
            this.stopBtn.disabled = !isRunning;
        }
    }

    /**
     * Проверяет статус выполнения сценариев при загрузке popup.
     * Обновляет состояние кнопок управления соответственно.
     */
    async checkScenarioStatusOnLoad() {
        console.log("[PopupApp] Проверка статуса сценариев при загрузке...");
        try {
            const response = await chrome.runtime.sendMessage({
                action: "getScenarioStatus"
            });

            if (response && response.status === "success") {
                const isRunning = response.isRunning;
                console.log(`[PopupApp] Статус сценариев при загрузке: isRunning=${isRunning}`);
                this.updateScenarioControlButtons(isRunning);

                // Опционально: можно отобразить уведомление, если сценарии выполняются
                if (isRunning) {
                    const count = response.runningScenarios?.length || 1;
                    document.dispatchEvent(new CustomEvent('log', {
                        detail: {
                            message: `ℹ️ При загрузке popup обнаружено запущенных сценариев: ${count}. Кнопка "Остановить" активна.`,
                            level: 'info'
                        }
                    }));
                }
            } else {
                console.warn("[PopupApp] Не удалось получить статус сценариев при загрузке:", response?.message);
                // В случае ошибки оставляем кнопки в начальном состоянии (не запущено)
                this.updateScenarioControlButtons(false);
            }
        } catch (err) {
            console.error("[PopupApp] Ошибка при проверке статуса сценариев при загрузке:", err);
            // В случае ошибки оставляем кнопки в начальном состоянии (не запущено)
            this.updateScenarioControlButtons(false);
        }
    }
}

// Запускаем приложение
document.addEventListener('DOMContentLoaded', () => {
    new PopupApp();
});


=== END FILE: D:\разработка\youtube-parser-os\popup\popup.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\components\ControlSection.js ===

export class ControlSection {
    constructor() {
        // Обновляем ID элементов в соответствии с popup.html
        this.runScenarioBtn = document.getElementById('runScenarioBtn'); // <-- Изменено
        this.stopBtn = document.getElementById('stopBtn');
        this.copyTableBtn = document.getElementById('copyTableBtn');
        this.clearTableBtn = document.getElementById('clearTableBtn');
        this.clearLogBtn = document.getElementById('clearLogBtn');
        this.resetIndicesBtn = document.getElementById('resetIndicesBtn');
        this.dumpIndicesBtn = document.getElementById('dumpIndicesBtn');
        // Добавляем ссылку на селектор сценариев
        this.scenarioSelector = document.getElementById('scenarioSelector'); // <-- Новое

        this.init();
    }

    init() {
        // Слушаем внутренние события от popup контроллера
        document.addEventListener('control:enableStart', () => this.enableStart());
        document.addEventListener('control:disableStart', () => this.disableStart());

        if (this.resetIndicesBtn) {
            this.resetIndicesBtn.addEventListener('click', () => this.handleResetIndices());
        } else {
            console.warn("[ControlSection] Кнопка 'resetIndicesBtn' не найдена в DOM.");
        }

        // 👇 НОВЫЙ обработчик для кнопки вывода состояния
        if (this.dumpIndicesBtn) {
            this.dumpIndicesBtn.addEventListener('click', () => this.handleDumpIndices());
        } else {
            console.warn("[ControlSection] Кнопка 'dumpIndicesBtn' не найдена в DOM.");
        }

        // Привязываем обработчики событий UI

        this.stopBtn.addEventListener('click', () => {
            document.dispatchEvent(new CustomEvent('stopAnalysis')); // Это событие уже отправляется
        });

        this.copyTableBtn.addEventListener('click', () => {
            document.dispatchEvent(new CustomEvent('copyTable'));
        });

        this.clearTableBtn.addEventListener('click', () => {
            document.dispatchEvent(new CustomEvent('clearTable'));
        });

        this.clearLogBtn.addEventListener('click', () => {
            document.dispatchEvent(new CustomEvent('clearLog'));
        });
    }

    handleStart() {
        const iterations = parseInt(document.getElementById('iterationsInput').value) || 10;
        const mode = document.querySelector('input[name="selectionMode"]:checked')?.value || 'smart';

        this.dispatchEvent('startAnalysis', { iterations, mode });
        this.startBtn.disabled = true;
        this.stopBtn.disabled = false;
    }

    handleStop() {
        this.dispatchEvent('stopAnalysis');
        this.startBtn.disabled = false;
        this.stopBtn.disabled = true;
    }

    handleCopyTable() {
        this.dispatchEvent('copyTable');
    }

    handleClearTable() {
        this.dispatchEvent('clearTable');
    }

    handleClearLog() {
        this.dispatchEvent('clearLog');
    }

    async handleResetIndices() {
        console.log("[ControlSection] Начало handleResetIndices");
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '📤 Отправка команды на сброс индексов...', level: 'info' } }));

        try {
            // Отправляем сообщение в background
            const response = await chrome.runtime.sendMessage({
                action: "resetIndices"
            });

            if (response && response.status === "success") {
                console.log("[ControlSection] Индексы успешно сброшены в background");
                document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Индексы успешно сброшены', level: 'success' } }));
                // Опционально: можно отправить событие, если другим компонентам нужно знать
                // document.dispatchEvent(new CustomEvent('indicesReset'));
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка';
                console.error("[ControlSection] Ошибка сброса индексов в background:", errorMsg);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка сброса индексов: ${errorMsg}`, level: 'error' } }));
            }
        } catch (err) {
            console.error("[ControlSection] Ошибка отправки команды сброса индексов в background:", err);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка связи: ${err.message}`, level: 'error' } }));
        }
    }

    async handleDumpIndices() {
        console.log("[ControlSection] Начало handleDumpIndices");
        document.dispatchEvent(new CustomEvent('log', { detail: { message: '🔍 Запрос состояния индексов...', level: 'info' } }));

        try {
            // Отправляем сообщение в background для получения состояния
            const response = await chrome.runtime.sendMessage({
                action: "getIndexState"
            });

            if (response && response.status === "success") {
                const state = response.serializableState;
                console.log("[ControlSection] === Состояние индексов IndexManager ===");

                // Выводим данные из объекта state с пояснениями
                console.log(`scrapedDataBuffer:`, `${state.scrapedDataBuffer_count} элементов`, state.scrapedDataBuffer_sample);
                console.log(`visitedVideoIds:`, `${state.visitedVideoIds_count} элементов`, state.visitedVideoIds_sample);
                console.log(`channelVideoCounts:`, `${state.channelVideoCounts_count} элементов`, state.channelVideoCounts_sample);
                console.log(`channelToVideoIds:`, `${state.channelToVideoIds_count} элементов`, state.channelToVideoIds_sample);

                console.log("[ControlSection] === Конец состояния индексов ===");

                document.dispatchEvent(new CustomEvent('log', { detail: { message: '✅ Состояние индексов выведено в консоль background', level: 'success' } }));
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка';
                console.error("[ControlSection] Ошибка получения состояния индексов из background:", errorMsg);
                document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка получения состояния индексов: ${errorMsg}`, level: 'error' } }));
            }
        } catch (err) {
            console.error("[ControlSection] Ошибка отправки запроса состояния индексов в background:", err);
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `❌ Ошибка связи: ${err.message}`, level: 'error' } }));
        }
    }

    enableStart() {
        // Логика включена в PopupApp.updateScenarioControlButtons
        if (this.runScenarioBtn) this.runScenarioBtn.disabled = false;
        if (this.stopBtn) this.stopBtn.disabled = true;
    }

    disableStart() {
        // Логика включена в PopupApp.updateScenarioControlButtons
        if (this.runScenarioBtn) this.runScenarioBtn.disabled = true;
        if (this.stopBtn) this.stopBtn.disabled = false;
    }

    dispatchEvent(type, detail) {
        document.dispatchEvent(new CustomEvent(type, { detail }));
    }
}


=== END FILE: D:\разработка\youtube-parser-os\popup\components\ControlSection.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\components\LogSection.js ===

// popup/components/LogSection.js
export class LogSection {
    constructor() {
        this.container = document.getElementById('logContainer');
        this.init();
    }

    init() {
        // Слушаем внутренние события для добавления логов
        document.addEventListener('log', (e) => {
            this.addLog(e.detail);
        });
        document.addEventListener('clearLog', () => this.clear());
        // При инициализации сразу загружаем начальные логи
        this.loadInitialLogs();
    }

    /**
     * Загружает и отображает начальные логи из хранилища.
     */
    async loadInitialLogs() {
        try {
            // Получаем логи напрямую из chrome.storage.local
            // В будущем это можно будет заменить на вызов нового Logger API
            const result = await chrome.storage.local.get(['appLogs']);
            const logs = result.appLogs || [];

            // Очищаем контейнер и убираем placeholder
            this.container.innerHTML = '';

            if (logs.length === 0) {
                // Если логов нет, показываем placeholder
                this.#showPlaceholder();
            } else {
                // Отображаем последние N логов, например, последние 100
                const logsToShow = logs.slice(-100);
                logsToShow.forEach(logEntry => {
                    // Используем существующий метод addLog, но без прокрутки
                    this.#renderLogEntry(logEntry);
                });
                // Прокручиваем вниз только один раз, после добавления всех начальных логов
                this.container.scrollTop = this.container.scrollHeight;
            }
        } catch (error) {
            console.error("LogSection: Ошибка при загрузке начальных логов:", error);
            // Даже в случае ошибки показываем placeholder
            this.#showPlaceholder();
            // Можно также залогировать ошибку в UI
            this.addLog({ message: `⚠️ Ошибка загрузки журнала: ${error.message}`, level: 'error' });
        }
    }

    /**
     * Добавляет запись в журнал событий, учитывая позицию прокрутки пользователя.
     * @param {Object} logEntry - Объект записи лога.
     * @param {string} logEntry.message - Текст сообщения.
     * @param {string} logEntry.level - Уровень лога ('info', 'success', 'warn', 'error').
     * @param {number} logEntry.timestamp - Временная метка.
     */
    addLog({ message, level = 'info', timestamp = Date.now() }) {
        // Удаляем placeholder, если он есть
        const placeholder = this.container.querySelector('.log-placeholder');
        if (placeholder) {
            placeholder.remove();
        }

        const entry = document.createElement('div');
        entry.className = `log-entry log-level-${level}`;
        const time = new Date(timestamp).toLocaleTimeString();
        entry.textContent = `[${time}] ${message}`;

        // --- Логика умной прокрутки ---
        const container = this.container;
        const isScrolledToBottom = (container.scrollHeight - container.clientHeight) <= (container.scrollTop + 1);
        container.appendChild(entry);
        if (isScrolledToBottom) {
            container.scrollTop = container.scrollHeight;
        }
        // ---
    }

    /**
     * Очищает журнал и показывает placeholder.
     */
    clear() {
        this.container.innerHTML = '';
        this.#showPlaceholder();
        // Опционально: можно залогировать факт очистки
        // this.addLog({ message: '🧹 Журнал очищен', level: 'info' });
    }

    // --- Вспомогательные методы ---

    /**
     * Показывает placeholder "Журнал пуст".
     */
    #showPlaceholder() {
        const placeholder = document.createElement('div');
        placeholder.className = 'log-placeholder';
        placeholder.textContent = 'Журнал пуст';
        this.container.appendChild(placeholder);
    }

    /**
     * Внутренний метод для рендеринга одной записи без логики прокрутки.
     * Используется при загрузке начальных логов.
     * @private
     */
    #renderLogEntry({ message, level = 'info', timestamp = Date.now() }) {
        // Placeholder удаляется первой записью
        const placeholder = this.container.querySelector('.log-placeholder');
        if (placeholder) {
            placeholder.remove();
        }

        const entry = document.createElement('div');
        entry.className = `log-entry log-level-${level}`;
        const time = new Date(timestamp).toLocaleTimeString();
        entry.textContent = `[${time}] ${message}`;
        this.container.appendChild(entry);
        // Прокрутка НЕ происходит здесь
    }
}

=== END FILE: D:\разработка\youtube-parser-os\popup\components\LogSection.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\components\SettingsSection.js ===

export class SettingsSection {
    constructor() {
        this.element = document.getElementById('settingsSection');
        this.toggleBtn = document.getElementById('toggleSettingsBtn');
        this.selectionModeRadios = document.querySelectorAll('input[name="selectionMode"]');
        this.iterationsInput = document.getElementById('iterationsInput');
        this.importTextarea = document.getElementById('importTextarea');
        this.importDataBtn = document.getElementById('importDataBtn');
        this.clearImportedBtn = document.getElementById('clearImportedBtn');

        this.init();
    }

    init() {
        // Восстанавливаем состояние из localStorage
        this.restoreState();

        // Обработчики
        this.toggleBtn.addEventListener('click', () => this.toggle());
        this.selectionModeRadios.forEach(radio => {
            radio.addEventListener('change', () => this.saveState());
        });
        this.iterationsInput.addEventListener('change', () => this.saveState());
        this.importDataBtn.addEventListener('click', () => this.handleImport());
        this.clearImportedBtn.addEventListener('click', () => this.handleClearImported());

        // Сохраняем при потере фокуса
        this.iterationsInput.addEventListener('blur', () => this.saveState());
    }

    toggle() {
        const isCollapsed = this.element.classList.contains('collapsed');
        if (isCollapsed) {
            this.expand();
        } else {
            this.collapse();
        }
        this.saveState();
    }

    collapse() {
        this.element.classList.add('collapsed');
        this.toggleBtn.textContent = '🔽';
    }

    expand() {
        this.element.classList.remove('collapsed');
        this.toggleBtn.textContent = '▲';
    }

    saveState() {
        const state = {
            isCollapsed: this.element.classList.contains('collapsed'),
            selectionMode: document.querySelector('input[name="selectionMode"]:checked')?.value || 'smart',
            iterations: this.iterationsInput.value,
        };
        localStorage.setItem('settingsState', JSON.stringify(state));
    }

    restoreState() {
        const saved = localStorage.getItem('settingsState');
        if (saved) {
            const state = JSON.parse(saved);
            if (state.isCollapsed) {
                this.collapse();
            } else {
                this.expand();
            }
            if (state.selectionMode) {
                const radio = document.querySelector(`input[name="selectionMode"][value="${state.selectionMode}"]`);
                if (radio) radio.checked = true;
            }
            if (state.iterations) {
                this.iterationsInput.value = state.iterations;
            }
        }
    }

    handleImport() {
        const text = this.importTextarea.value.trim();

        if (!text) {
            this.dispatchEvent('log', { message: '❌ Нет данных для импорта', level: 'error' });
            return;
        }

        try {
            const data = this.parseCSV(text);

            if (data.length === 0) {
                this.dispatchEvent('log', { message: '❌ Нет данных для импорта после парсинга', level: 'error' });
                return;
            }

            const dataWithFlag = data.map((item, index) => {
                const newItem = {
                    ...item,
                    isImported: true, // Добавляем флаг
                    timestamp: item.timestamp || Date.now() // Убеждаемся, что timestamp есть
                };
                return newItem;
            });

            this.dispatchEvent('importData', { data: dataWithFlag }); // ВАЖНО: ключ 'data'
            this.importTextarea.value = '';
            this.dispatchEvent('log', { message: `✅ Импортировано ${dataWithFlag.length} записей`, level: 'success' });
        } catch (err) {
            console.error("[SettingsSection] Ошибка импорта:", err);
            this.dispatchEvent('log', { message: `❌ Ошибка импорта: ${err.message}`, level: 'error' });
        }
    }

    async handleClearImported() {
        console.log("[SettingsSection] Начало handleClearImported");
        this.dispatchEvent('log', { message: '📤 Отправка команды на очистку импортированных данных...', level: 'info' });

        try {
            // Отправляем сообщение в background
            const response = await chrome.runtime.sendMessage({
                action: "clearImportedTableData"
            });

            if (response && response.status === "success") {
                console.log("[SettingsSection] Импортированные данные успешно очищены в background");
                this.dispatchEvent('log', { message: '✅ Импортированные данные очищены', level: 'success' });
                // Опционально: можно отправить событие, если другим компонентам нужно знать
                // this.dispatchEvent('importedDataCleared');
            } else {
                const errorMsg = response?.message || 'Неизвестная ошибка';
                console.error("[SettingsSection] Ошибка очистки в background:", errorMsg);
                this.dispatchEvent('log', { message: `❌ Ошибка очистки: ${errorMsg}`, level: 'error' });
            }
        } catch (err) {
            console.error("[SettingsSection] Ошибка отправки команды в background:", err);
            this.dispatchEvent('log', { message: `❌ Ошибка связи: ${err.message}`, level: 'error' });
        }
    }

    parseCSV(text) {
        const lines = text.split(/\r?\n/);
        if (lines.length === 0) {
            throw new Error('Пустой файл');
        }

        // Определяем разделитель: сначала пробуем ';', затем ','
        let delimiter = ';';
        if (lines[0].includes(',') && !lines[0].includes(';')) {
            delimiter = ',';
        }

        const headers = lines[0].split(delimiter).map(h => h.trim().toLowerCase());

        const required = ['название', 'id', 'просмотры', 'канал', 'исходное видео', 'миниатюра'];
        const fieldMap = {
            'название': 'title',
            'id': 'videoId',
            'просмотры': 'views',
            'канал': 'channelName',
            'исходное видео': 'sourceVideoId',
            'миниатюра': 'thumbnailUrl'
        };

        const indices = {};
        required.forEach(field => {
            const index = headers.findIndex(h => h === field);
            if (index === -1) {
                console.error("[SettingsSection] Не найдена колонка:", field);
                throw new Error(`Не найдена колонка: ${field}`);
            }
            indices[field] = index;
        });

        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) {
                continue;
            }
            const cells = line.split(delimiter).map(cell => {
                // Убираем окружающие кавычки, если они есть
                let trimmed = cell.trim();
                if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
                    trimmed = trimmed.substring(1, trimmed.length - 1);
                }
                return trimmed;
            });

            if (cells.length < headers.length) {
                console.warn(`[SettingsSection] Недостаточно ячеек в строке ${i}, пропускаем`);
                continue; // Пропускаем строки с недостаточным количеством ячеек
            }

            const item = {};
            required.forEach(field => {
                const index = indices[field];
                item[fieldMap[field]] = cells[index] ? cells[index] : '';
            });
            data.push(item);
        }
        return data;
    }

    dispatchEvent(type, detail) {
        document.dispatchEvent(new CustomEvent(type, { detail }));
    }
}

=== END FILE: D:\разработка\youtube-parser-os\popup\components\SettingsSection.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\popup\components\TableSection.js ===

// popup/components/TableSection.js

export class TableSection {
    constructor() {
        this.tableBody = document.getElementById('tableBody');
        this.init();
    }

    init() {
        // Слушаем внутренние события
        document.addEventListener('updateTable', (e) => this.render(e.detail));
        document.addEventListener('clearTable', () => this.clear());
        // При инициализации сразу загружаем начальные данные
        this.loadInitialData();
    }

    /**
     * Загружает и отображает начальные данные из хранилища.
     * Запрашивает только "свежие" (не импортированные) данные.
     */
    async loadInitialData() {
        console.log("TableSection: Загрузка начальных данных (только свежие)...");
        try {
            // Отправляем сообщение в background для получения ТОЛЬКО свежих данных
            const response = await chrome.runtime.sendMessage({ action: "getTableFreshData" });
            const data = response?.data || [];
            console.log(`TableSection: Получено ${data.length} свежих записей.`);
            this.render(data);
        } catch (error) {
            console.error("TableSection: Ошибка при загрузке начальных данных:", error);
            this.clear();
            document.dispatchEvent(new CustomEvent('log', { detail: { message: `⚠️ Ошибка загрузки таблицы: ${error.message}`, level: 'error' } }));
        }
    }

    /**
     * Рендерит данные в таблицу.
     * @param {Array<Object>} data - Массив объектов видео.
     */
    render(data = []) {
        this.tableBody.innerHTML = '';
        if (data.length === 0) {
            this.#showPlaceholder();
            return;
        }

        // Ограничиваем количество отображаемых строк для производительности
        const dataToShow = data.slice(-50); // последние 50

        dataToShow.forEach(video => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${this.#escapeHtml(video.title || '')}</td>
                <td>${this.#escapeHtml(video.videoId || '')}</td>
                <td>${this.#escapeHtml(video.views || '')}</td>
                <td>${this.#escapeHtml(video.channelName || '')}</td>
                <td>${this.#escapeHtml(video.sourceVideoId || '')}</td>
                <td>
                    ${video.thumbnailUrl ?
                    `<img src="${video.thumbnailUrl}" alt="Thumbnail" onerror="this.parentElement.innerHTML='—'">` :
                    '—'}
                </td>
            `;
            this.tableBody.appendChild(row);
        });
    }

    /**
     * Очищает таблицу и показывает placeholder.
     */
    clear() {
        this.tableBody.innerHTML = '';
        this.#showPlaceholder();
    }

    // --- Вспомогательные методы ---

    /**
     * Показывает placeholder "Таблица пуста".
     * @private
     */
    #showPlaceholder() {
        const placeholderRow = document.createElement('tr');
        placeholderRow.className = 'table-placeholder';
        placeholderRow.innerHTML = `<td colspan="6">Таблица пуста</td>`;
        this.tableBody.appendChild(placeholderRow);
    }

    /**
     * Экранирует HTML-сущности.
     * @param {string} text - Текст для экранирования.
     * @returns {string} - Экранированный текст.
     * @private
     */
    #escapeHtml(text) {
        if (typeof text !== 'string') return '';
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "<")
            .replace(/>/g, ">")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
}

=== END FILE: D:\разработка\youtube-parser-os\popup\components\TableSection.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\scenarios\parse-recommendation.js ===


// scenarios/parse-recommendation.js
import { scrollPageNTimes } from '../core/utils/scroller.js';
import { parseAndHighlight, removeParserHighlights } from '../core/utils/parser.js';
import { addScrapedData as updateIndexManager } from '../core/index-manager.js';
import { logger } from '../background/background.js'; // Убедись, что logger доступен
import { tableAdapter } from '../background/background.js'; // 👈 НОВОЕ: Импорт tableAdapter
import { getUnavailableVideoIds, addUnavailableVideoIds } from '../core/utils/blacklist.js';
import { selectNextVideo } from '../core/utils/video-selector.js';
import { getStateSnapshot } from '../core/index-manager.js';
/**
 * @type {import('../core/types/scenario.types.js').ScenarioDefinition}
 */
export const parseRecommendationScenario = {
    id: 'parse-recommendation',
    name: 'Парсинг рекомендаций',
    description: 'Прокручивает страницу с рекомендациями и готовит данные для парсинга.',

    /**
     * @param {import('../core/types/scenario.types.js').ScenarioContext} context
     */
    async execute(context) {
        const { log, params = {}, tabId, abortSignal } = context;
        console.log("[ParseRecommendation] Начало выполнения, context:", { params, tabId }); // <-- Лог

        // Параметры по умолчанию, как указано в задаче
        const scrollParams = {
            count: parseInt(params.count, 10) || 16,
            delayMs: parseInt(params.delayMs, 10) || 1500,
            step: parseInt(params.step, 10) || 1000
        };

        const selectionMode = params.mode || 'all_videos'; // По умолчанию 'all_videos'
        const internalSelectionMode = selectionMode;

        log(`🚀 Сценарий "Парсинг рекомендаций" запущен.`, { module: 'ParseRecommendation' });
        log(`🔧 Параметры скроллинга: ${JSON.stringify(scrollParams)}`, { module: 'ParseRecommendation' });
        log(`🧠 Алгоритм выбора следующего видео: ${internalSelectionMode}`, { module: 'ParseRecommendation' }); // 👈 НОВОЕ

        try {
            // Проверяем, не было ли запроса на остановку до начала
            log(`⏳ Проверка abortSignal перед скроллингом...`, { module: 'ParseRecommendation' });
            await abortSignal();
            log(`✅ Проверка abortSignal пройдена.`, { module: 'ParseRecommendation' });

            // --- 0. НОВОЕ: Проверка доступности текущего видео ---
            log(`🔒 Проверка доступности текущего видео...`, { module: 'ParseRecommendation' });
            try {
                // Получаем URL текущей вкладки
                if (typeof tabId !== 'number' || tabId < 0) {
                    throw new Error(`Недействительный tabId: ${tabId}`);
                }
                const tab = await chrome.tabs.get(tabId);
                const currentUrl = tab.url;
                log(`🔒 Текущий URL: ${currentUrl}`, { module: 'ParseRecommendation' });

                // Извлекаем videoId из URL
                let currentVideoId = null;
                try {
                    const url = new URL(currentUrl);
                    if (url.hostname.includes('youtube.com') && url.pathname === '/watch') {
                        currentVideoId = url.searchParams.get('v');
                    }
                } catch (urlErr) {
                    console.warn("[ParseRecommendation] Ошибка разбора URL:", urlErr);
                }

                if (!currentVideoId) {
                    log(`⚠️ Не удалось извлечь videoId из URL. Пропускаем проверку доступности.`, { module: 'ParseRecommendation', level: 'warn' });
                    // Продолжаем выполнение
                } else {
                    log(`🔒 Проверяем доступность видео ID: ${currentVideoId}...`, { module: 'ParseRecommendation' });

                    // Отправляем сообщение content script для проверки
                    const checkResponse = await chrome.tabs.sendMessage(tabId, {
                        action: "checkVideoAvailability"
                    });

                    if (checkResponse && checkResponse.status === "success") {
                        const isAvailable = checkResponse.isAvailable;
                        log(`🔒 Результат проверки для ${currentVideoId}: ${isAvailable ? 'Доступно' : 'Недоступно'}`, { module: 'ParseRecommendation', level: isAvailable ? 'info' : 'warn' });

                        if (!isAvailable) {
                            // Видео недоступно - добавляем в черный список
                            log(`🔒 Видео ${currentVideoId} недоступно. Добавляем в черный список.`, { module: 'ParseRecommendation', level: 'error' });
                            await addUnavailableVideoIds(currentVideoId);
                            log(`🔒 Видео ${currentVideoId} добавлено в черный список недоступных.`, { module: 'ParseRecommendation', level: 'warn' });

                            // Здесь можно решить, прерывать ли сценарий или продолжать
                            // Для MVP: прерываем сценарий
                            log(`⏹️ Сценарий остановлен из-за недоступности текущего видео (${currentVideoId}).`, { module: 'ParseRecommendation', level: 'error' });
                            throw new Error(`Текущее видео (${currentVideoId}) недоступно. Добавлено в черный список.`);

                            // Альтернатива: продолжить, но залогировать ошибку
                            // log(`⚠️ Текущее видео недоступно, но сценарий продолжится.`, { module: 'ParseRecommendation', level: 'warn' });
                        } else {
                            log(`✅ Текущее видео доступно. Продолжаем выполнение.`, { module: 'ParseRecommendation' });
                        }
                    } else {
                        const checkErrorMsg = checkResponse?.message || "Неизвестная ошибка проверки";
                        log(`⚠️ Ошибка проверки доступности: ${checkErrorMsg}`, { module: 'ParseRecommendation', level: 'warn' });
                        // Продолжаем выполнение, несмотря на ошибку проверки
                    }
                }
            } catch (checkErr) {
                log(`⚠️ Ошибка связи при проверке доступности: ${checkErr.message}`, { module: 'ParseRecommendation', level: 'warn' });
                // Продолжаем выполнение, несмотря на ошибку связи
            }
            // --- 1. Скроллинг страницы ---
            log(`🔄 Вызов scrollPageNTimes...`, { module: 'ParseRecommendation' });
            await scrollPageNTimes(context, scrollParams.count, scrollParams.delayMs, scrollParams.step);
            log(`✅ scrollPageNTimes завершен.`, { module: 'ParseRecommendation' });

            // --- 2. Парсинг и подсветка ---
            await removeParserHighlights(context);

            const parseResult = await parseAndHighlight(context);
            const highlightedCount = parseResult.highlightedCount;
            const scrapedData = parseResult.scrapedData || [];

            log(`✅ Найдено и подсвечено ${highlightedCount} видео.`, { module: 'ParseRecommendation' });

            // Для отладки: логируем количество полученных HTML
            log(`📄 Получено HTML-кодов карточек: ${scrapedData?.length || 0}`, { module: 'ParseRecommendation' });

            if (scrapedData.length > 0) {
                log(`🔄 Обновление индексов IndexManager данными по ${scrapedData.length} видео...`, { module: 'ParseRecommendation' });
                try {
                    // Передаем извлеченные данные в IndexManager
                    updateIndexManager(scrapedData);
                    log(`✅ Индексы IndexManager успешно обновлены.`, { module: 'ParseRecommendation' });
                } catch (indexUpdateErr) {
                    log(`❌ Ошибка обновления индексов IndexManager: ${indexUpdateErr.message}`, { module: 'ParseRecommendation', level: 'error' });
                    // Не прерываем сценарий из-за ошибки обновления индексов, это вторично
                }
            } else {
                log(`ℹ️ Нет новых данных для обновления индексов.`, { module: 'ParseRecommendation' });
            }
            // --- 4. Загрузить данные в таблицу
            if (scrapedData.length > 0) {
                log(`💾 Сохранение ${scrapedData.length} записей в таблицу...`, { module: 'ParseRecommendation' });
                try {
                    // Добавляем временной штамп, если его нет
                    const dataToSave = scrapedData.map(item => ({
                        ...item,
                        timestamp: item.timestamp || Date.now() // Добавляем timestamp, если отсутствует
                    }));

                    // Используем tableAdapter для сохранения данных
                    // Предполагается, что tableAdapter.addBatch существует
                    if (typeof tableAdapter.addBatch === 'function') {
                        await tableAdapter.addBatch(dataToSave);
                        log(`✅ ${dataToSave.length} записей успешно сохранены в таблицу.`, { module: 'ParseRecommendation' });
                    } else if (typeof tableAdapter.add === 'function') {
                        // Если addBatch нет, добавляем по одной (менее эффективно)
                        log(`⚠️ tableAdapter.addBatch не найден, сохраняем по одной записи...`, { module: 'ParseRecommendation', level: 'warn' });
                        let savedCount = 0;
                        for (const item of dataToSave) {
                            try {
                                await tableAdapter.add(item);
                                savedCount++;
                            } catch (addItemErr) {
                                log(`❌ Ошибка сохранения одной записи: ${addItemErr.message}`, { module: 'ParseRecommendation', level: 'error' });
                                // Не прерываем весь процесс из-за одной ошибки
                            }
                        }
                        log(`✅ ${savedCount}/${dataToSave.length} записей успешно сохранены в таблицу (по одной).`, { module: 'ParseRecommendation' });
                    } else {
                        throw new Error("Адаптер таблицы не поддерживает методы добавления (add/addBatch)");
                    }

                } catch (saveErr) {
                    log(`❌ Ошибка сохранения данных в таблицу: ${saveErr.message}`, { module: 'ParseRecommendation', level: 'error' });
                    // Не прерываем сценарий из-за ошибки сохранения, это вторично
                }
            } else {
                log(`ℹ️ Нет новых данных для сохранения в таблицу.`, { module: 'ParseRecommendation' });
            }

            // --- 5. Выбор следующего видео
            if (scrapedData.length > 0) {
                log(`🤔 Попытка выбора следующего видео...`, { module: 'ParseRecommendation' });
                try {
                    // Получаем ID текущего видео (источника)
                    let currentSourceVideoId = 'unknown_source';
                    if (typeof tabId === 'number' && tabId > 0) {
                        try {
                            const tab = await chrome.tabs.get(tabId);
                            const url = new URL(tab.url);
                            currentSourceVideoId = url.searchParams.get('v') || 'unknown_source_from_url';
                        } catch (urlErr) {
                            log(`⚠️ Ошибка получения текущего videoId из URL: ${urlErr.message}`, { module: 'ParseRecommendation', level: 'warn' });
                        }
                    }
                    log(`📍 Текущее видео (источник): ${currentSourceVideoId}`, { module: 'ParseRecommendation' });

                    // 👇 НОВОЕ: Получаем необходимые зависимости из IndexManager
                    const indexSnapshot = getStateSnapshot(); // Получаем копию состояния
                    const dependencies = {
                        visitedSourceVideoIds: indexSnapshot.visitedVideoIds, // Это Set<sourceVideoId>
                        channelVideoCounts: indexSnapshot.channelVideoCounts, // Это Map<channel, count>
                        channelToVideoIds: indexSnapshot.channelToVideoIds // Это Map<channel, Set<videoId>>
                    };

                    // 👇 НОВОЕ: Получаем режим выбора из параметров сценария
                    // Убедитесь, что params.mode содержит 'current_recommendations' или 'all_videos'
                    // Если в UI у вас другие значения, их нужно преобразовать
                    const selectionModeInternal = params.mode || 'all_videos'; // Дефолтный режим

                    // 👇 ИСПРАВЛЕННЫЙ ВЫЗОВ selectNextVideo
                    const nextVideoId = await selectNextVideo(
                        dependencies,              // 1. Объект с зависимостями
                        currentSourceVideoId,      // 2. ID текущего видео (источника)
                        selectionModeInternal,     // 3. Режим выбора
                        scrapedData,               // 4. Данные для 'current_recommendations'
                        context                    // 5. Контекст для логирования (log)
                    );

                    if (nextVideoId) {
                        log(`🎉 Выбрано следующее видео для перехода: ${nextVideoId}`, { module: 'ParseRecommendation', level: 'success' });
                        // TODO: Здесь будет логика перехода на nextVideoId в следующем шаге
                    } else {
                        log(`⚠️ Не удалось выбрать следующее видео.`, { module: 'ParseRecommendation', level: 'warn' });
                    }
                } catch (selectErr) {
                    log(`❌ Ошибка выбора следующего видео: ${selectErr.message}`, { module: 'ParseRecommendation', level: 'error' });
                    console.error("[ParseRecommendation] Stack trace ошибки выбора:", selectErr); // Для отладки
                }
            } else {
                log(`ℹ️ Нет данных для выбора следующего видео.`, { module: 'ParseRecommendation' });
            }

            log(`🎉 Сценарий "Парсинг рекомендаций" успешно завершён.`, { module: 'ParseRecommendation' });

        } catch (error) {
            console.error("[ParseRecommendation] Поймано исключение:", error); // <-- Лог ошибок

            if (error.message === 'Сценарий остановлен пользователем.') {
                log(`⏹️ Сценарий "Парсинг рекомендаций" остановлен пользователем.`, { module: 'ParseRecommendation', level: 'warn' });
            } else {
                log(`❌ Ошибка в сценарии "Парсинг рекомендаций": ${error.message}`, { module: 'ParseRecommendation', level: 'error' });
                throw error; // Перебрасываем ошибку для обработки в ScenarioEngine
            }
        }
    }
};


=== END FILE: D:\разработка\youtube-parser-os\scenarios\parse-recommendation.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\scenarios\test-countdown.js ===

// scenarios/test-countdown.js
import { logger } from '../background/background.js';
import { tableAdapter } from '../background/background.js';

// --- Переносим вспомогательные функции внутрь модуля ---
/**
 * Генерирует случайную строку заданной длины.
 * @param {number} length
 * @returns {string}
 */
function generateRandomString(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}

/**
 * Генерирует случайное число просмотров.
 * @returns {string}
 */
function generateRandomViews() {
    const num = Math.floor(Math.random() * 1000000);
    if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
    if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
    return num.toString();
}
// --- Конец вспомогательных функций ---

/**
 * @type {import('../core/types/scenario.types.js').ScenarioDefinition}
 */
export const testCountdownScenario = {
    id: 'test-countdown',
    name: 'Тестовый сценарий: Обратный отсчет',
    description: 'Считает от 1 до N, где N - количество итераций из настроек. Логирует выбранный алгоритм.',

    /**
     * @param {import('../core/types/scenario.types.js').ScenarioContext} context
     */
    async execute(context) {
        // 1. Получаем параметры из контекста
        const { log, abortSignal, params = {} } = context;

        // 2. Извлекаем параметры или используем значения по умолчанию
        // ВАЖНО: ключи params должны совпадать с тем, что отправляется из popup/background
        const maxCount = parseInt(params.iterations, 10) || 10;
        // Интерпретируем внутренние значения mode в человекочитаемые названия для логов
        let selectionModeLabel = 'Неизвестный режим';
        if (params.mode === 'all_videos') {
            selectionModeLabel = 'Анализ всех видео';
        } else if (params.mode === 'current_recommendations') {
            selectionModeLabel = 'Анализ видео из последней подборки';
        }
        // Используем внутреннее значение mode для логики (если потребуется в будущем)
        const mode = params.mode || 'all_videos';
        const sourceVideoId = 'test_source_video_id'; // Для теста

        // 3. Логируем начальные параметры (используем человекочитаемое название)
        log(`🚀 Тестовый сценарий запущен.`, { module: 'TestScenario' });
        log(`🔢 Количество шагов: ${maxCount}`, { module: 'TestScenario' });
        log(`🧠 Алгоритм выбора: ${selectionModeLabel}`, { module: 'TestScenario' });
        // 4. Основной цикл
        for (let i = 1; i <= maxCount; i++) {
            // Проверяем, не был ли запрос на остановку
            await abortSignal();

            log(`⏱️ Шаг ${i}/${maxCount}`, { module: 'TestScenario' });

            // --- Запись случайных данных в таблицу ---
            try {
                const randomVideoData = {
                    videoId: `test_video_${generateRandomString(8)}`,
                    title: `Тестовое видео ${i}: ${generateRandomString(15)}`,
                    channelName: `Тестовый канал ${generateRandomString(5)}`,
                    views: generateRandomViews(),
                    sourceVideoId: sourceVideoId,
                    thumbnailUrl: `https://picsum.photos/seed/${i}/120/90`, // URL к случайной картинке
                    timestamp: Date.now()
                };

                await tableAdapter.add(randomVideoData);
                log(`💾 Данные шага ${i} записаны в таблицу.`, { module: 'TestScenario' });
            } catch (err) {
                log(`❌ Ошибка записи данных шага ${i}: ${err.message}`, { module: 'TestScenario', level: 'error' });
            }
            // --- Конец записи данных ---

            // Ждем 1 секунду
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        // 5. Логируем завершение и снова указываем параметры
        log(`🎉 Тестовый сценарий завершен.`, { module: 'TestScenario' });
        log(`🧠 Использованный алгоритм: ${selectionModeLabel}`, { module: 'TestScenario' });
        log(`🔢 Выполнено шагов: ${maxCount}`, { module: 'TestScenario' });
    }
};

=== END FILE: D:\разработка\youtube-parser-os\scenarios\test-countdown.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\shared\logger.js ===



=== END FILE: D:\разработка\youtube-parser-os\shared\logger.js ===

--------------------------------------------------------------------------------

=== START FILE: D:\разработка\youtube-parser-os\shared\storage.js ===



=== END FILE: D:\разработка\youtube-parser-os\shared\storage.js ===

--------------------------------------------------------------------------------
